// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

import {ObjectMeta} from "../meta/v1";

export namespace extensions {
    export namespace v1alpha1 {
        /**
         * Extend the functionality provided by the Istio proxy through WebAssembly filters. See more details at: https://istio.io/docs/reference/config/proxy_extensions/wasm-plugin.html
         */
        export interface WasmPluginSpecArgs {
            /**
             * Specifies the failure behavior for the plugin due to fatal errors.
             */
            failStrategy?: pulumi.Input<string>;
            /**
             * The pull behaviour to be applied when fetching Wasm module by either OCI image or http/https.
             */
            imagePullPolicy?: pulumi.Input<string>;
            /**
             * Credentials to use for OCI image pulling.
             */
            imagePullSecret?: pulumi.Input<string>;
            /**
             * Specifies the criteria to determine which traffic is passed to WasmPlugin.
             */
            match?: pulumi.Input<pulumi.Input<inputs.extensions.v1alpha1.WasmPluginSpecMatchArgs>[]>;
            /**
             * Determines where in the filter chain this `WasmPlugin` is to be injected.
             */
            phase?: pulumi.Input<string>;
            /**
             * The configuration that will be passed on to the plugin.
             */
            pluginConfig?: pulumi.Input<{[key: string]: any}>;
            /**
             * The plugin name to be used in the Envoy configuration (used to be called `rootID`).
             */
            pluginName?: pulumi.Input<string>;
            /**
             * Determines ordering of `WasmPlugins` in the same `phase`.
             */
            priority?: pulumi.Input<number>;
            /**
             * Criteria used to select the specific set of pods/VMs on which this plugin configuration should be applied.
             */
            selector?: pulumi.Input<inputs.extensions.v1alpha1.WasmPluginSpecSelectorArgs>;
            /**
             * SHA256 checksum that will be used to verify Wasm module or OCI container.
             */
            sha256?: pulumi.Input<string>;
            targetRef?: pulumi.Input<inputs.extensions.v1alpha1.WasmPluginSpecTargetRefArgs>;
            /**
             * Specifies the type of Wasm Extension to be used.
             */
            type?: pulumi.Input<string>;
            /**
             * URL of a Wasm module or OCI container.
             */
            url: pulumi.Input<string>;
            verificationKey?: pulumi.Input<string>;
            /**
             * Configuration for a Wasm VM.
             */
            vmConfig?: pulumi.Input<inputs.extensions.v1alpha1.WasmPluginSpecVmConfigArgs>;
        }

        export interface WasmPluginSpecMatchArgs {
            /**
             * Criteria for selecting traffic by their direction.
             */
            mode?: pulumi.Input<string>;
            /**
             * Criteria for selecting traffic by their destination port.
             */
            ports?: pulumi.Input<pulumi.Input<inputs.extensions.v1alpha1.WasmPluginSpecMatchPortsArgs>[]>;
        }

        export interface WasmPluginSpecMatchPortsArgs {
            number: pulumi.Input<number>;
        }

        /**
         * Criteria used to select the specific set of pods/VMs on which this plugin configuration should be applied.
         */
        export interface WasmPluginSpecSelectorArgs {
            /**
             * One or more labels that indicate a specific set of pods/VMs on which a policy should be applied.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface WasmPluginSpecTargetRefArgs {
            group?: pulumi.Input<string>;
            kind?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            namespace?: pulumi.Input<string>;
        }

        /**
         * Configuration for a Wasm VM.
         */
        export interface WasmPluginSpecVmConfigArgs {
            /**
             * Specifies environment variables to be injected to this VM.
             */
            env?: pulumi.Input<pulumi.Input<inputs.extensions.v1alpha1.WasmPluginSpecVmConfigEnvArgs>[]>;
        }

        export interface WasmPluginSpecVmConfigEnvArgs {
            /**
             * Name of the environment variable.
             */
            name: pulumi.Input<string>;
            /**
             * Value for the environment variable.
             */
            value?: pulumi.Input<string>;
            /**
             * Source for the environment variable's value.
             */
            valueFrom?: pulumi.Input<string>;
        }
    }
}

export namespace networking {
    export namespace v1alpha3 {
        /**
         * Configuration affecting load balancing, outlier detection, etc. See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html
         */
        export interface DestinationRuleSpecArgs {
            /**
             * A list of namespaces to which this destination rule is exported.
             */
            exportTo?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * The name of a service from the service registry.
             */
            host: pulumi.Input<string>;
            /**
             * One or more named sets that represent individual versions of a service.
             */
            subsets?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecSubsetsArgs>[]>;
            /**
             * Traffic policies to apply (load balancing policy, connection pool sizes, outlier detection).
             */
            trafficPolicy?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecTrafficPolicyArgs>;
            /**
             * Criteria used to select the specific set of pods/VMs on which this `DestinationRule` configuration should be applied.
             */
            workloadSelector?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecWorkloadSelectorArgs>;
        }

        export interface DestinationRuleSpecSubsetsArgs {
            /**
             * Labels apply a filter over the endpoints of a service in the service registry.
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Name of the subset.
             */
            name: pulumi.Input<string>;
            /**
             * Traffic policies that apply to this subset.
             */
            trafficPolicy?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficPolicyArgs>;
        }

        /**
         * Traffic policies that apply to this subset.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyArgs {
            connectionPool?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolArgs>;
            /**
             * Settings controlling the load balancer algorithms.
             */
            loadBalancer?: any;
            outlierDetection?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficPolicyOutlierDetectionArgs>;
            /**
             * Traffic policies specific to individual ports.
             */
            portLevelSettings?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsArgs>[]>;
            /**
             * TLS related settings for connections to the upstream service.
             */
            tls?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficPolicyTlsArgs>;
            /**
             * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
             */
            tunnel?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficPolicyTunnelArgs>;
        }

        export interface DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolArgs {
            /**
             * HTTP connection pool settings.
             */
            http?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttpArgs>;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpArgs>;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttpArgs {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: pulumi.Input<string>;
            /**
             * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
             */
            http1MaxPendingRequests?: pulumi.Input<number>;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: pulumi.Input<number>;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: pulumi.Input<string>;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            /**
             * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
             */
            maxRetries?: pulumi.Input<number>;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: pulumi.Input<boolean>;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpArgs {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepaliveArgs>;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepaliveArgs {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: pulumi.Input<string>;
            /**
             * Maximum number of keepalive probes to send without response before deciding the connection is dead.
             */
            probes?: pulumi.Input<number>;
            /**
             * The time duration a connection needs to be idle before keep-alive probes start being sent.
             */
            time?: pulumi.Input<string>;
        }

        export interface DestinationRuleSpecSubsetsTrafficPolicyOutlierDetectionArgs {
            /**
             * Minimum ejection duration.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Number of 5xx errors before a host is ejected from the connection pool.
             */
            consecutive5xxErrors?: pulumi.Input<number>;
            consecutiveErrors?: pulumi.Input<number>;
            /**
             * Number of gateway errors before a host is ejected from the connection pool.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            /**
             * The number of consecutive locally originated failures before ejection occurs.
             */
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Time interval between ejection sweep analysis.
             */
            interval?: pulumi.Input<string>;
            /**
             * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
             */
            maxEjectionPercent?: pulumi.Input<number>;
            /**
             * Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode.
             */
            minHealthPercent?: pulumi.Input<number>;
            /**
             * Determines whether to distinguish local origin failures from external errors.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }

        export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsArgs {
            connectionPool?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolArgs>;
            /**
             * Settings controlling the load balancer algorithms.
             */
            loadBalancer?: any;
            outlierDetection?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetectionArgs>;
            /**
             * Specifies the number of a port on the destination service on which this policy is being applied.
             */
            port?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPortArgs>;
            /**
             * TLS related settings for connections to the upstream service.
             */
            tls?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTlsArgs>;
        }

        export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolArgs {
            /**
             * HTTP connection pool settings.
             */
            http?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpArgs>;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpArgs>;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpArgs {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: pulumi.Input<string>;
            /**
             * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
             */
            http1MaxPendingRequests?: pulumi.Input<number>;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: pulumi.Input<number>;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: pulumi.Input<string>;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            /**
             * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
             */
            maxRetries?: pulumi.Input<number>;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: pulumi.Input<boolean>;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpArgs {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepaliveArgs>;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepaliveArgs {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: pulumi.Input<string>;
            /**
             * Maximum number of keepalive probes to send without response before deciding the connection is dead.
             */
            probes?: pulumi.Input<number>;
            /**
             * The time duration a connection needs to be idle before keep-alive probes start being sent.
             */
            time?: pulumi.Input<string>;
        }

        export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetectionArgs {
            /**
             * Minimum ejection duration.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Number of 5xx errors before a host is ejected from the connection pool.
             */
            consecutive5xxErrors?: pulumi.Input<number>;
            consecutiveErrors?: pulumi.Input<number>;
            /**
             * Number of gateway errors before a host is ejected from the connection pool.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            /**
             * The number of consecutive locally originated failures before ejection occurs.
             */
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Time interval between ejection sweep analysis.
             */
            interval?: pulumi.Input<string>;
            /**
             * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
             */
            maxEjectionPercent?: pulumi.Input<number>;
            /**
             * Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode.
             */
            minHealthPercent?: pulumi.Input<number>;
            /**
             * Determines whether to distinguish local origin failures from external errors.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }

        /**
         * Specifies the number of a port on the destination service on which this policy is being applied.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPortArgs {
            number?: pulumi.Input<number>;
        }

        /**
         * TLS related settings for connections to the upstream service.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTlsArgs {
            /**
             * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
             */
            caCertificates?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            clientCertificate?: pulumi.Input<string>;
            /**
             * The name of the secret that holds the TLS certs for the client including the CA certificates.
             */
            credentialName?: pulumi.Input<string>;
            /**
             * InsecureSkipVerify specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
             */
            insecureSkipVerify?: pulumi.Input<boolean>;
            /**
             * Indicates whether connections to this port should be secured using TLS.
             */
            mode?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            privateKey?: pulumi.Input<string>;
            /**
             * SNI string to present to the server during TLS handshake.
             */
            sni?: pulumi.Input<string>;
            /**
             * A list of alternate names to verify the subject identity in the certificate.
             */
            subjectAltNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * TLS related settings for connections to the upstream service.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyTlsArgs {
            /**
             * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
             */
            caCertificates?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            clientCertificate?: pulumi.Input<string>;
            /**
             * The name of the secret that holds the TLS certs for the client including the CA certificates.
             */
            credentialName?: pulumi.Input<string>;
            /**
             * InsecureSkipVerify specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
             */
            insecureSkipVerify?: pulumi.Input<boolean>;
            /**
             * Indicates whether connections to this port should be secured using TLS.
             */
            mode?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            privateKey?: pulumi.Input<string>;
            /**
             * SNI string to present to the server during TLS handshake.
             */
            sni?: pulumi.Input<string>;
            /**
             * A list of alternate names to verify the subject identity in the certificate.
             */
            subjectAltNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyTunnelArgs {
            /**
             * Specifies which protocol to use for tunneling the downstream connection.
             */
            protocol?: pulumi.Input<string>;
            /**
             * Specifies a host to which the downstream connection is tunneled.
             */
            targetHost: pulumi.Input<string>;
            /**
             * Specifies a port to which the downstream connection is tunneled.
             */
            targetPort: pulumi.Input<number>;
        }

        /**
         * Traffic policies to apply (load balancing policy, connection pool sizes, outlier detection).
         */
        export interface DestinationRuleSpecTrafficPolicyArgs {
            connectionPool?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecTrafficPolicyConnectionPoolArgs>;
            /**
             * Settings controlling the load balancer algorithms.
             */
            loadBalancer?: any;
            outlierDetection?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecTrafficPolicyOutlierDetectionArgs>;
            /**
             * Traffic policies specific to individual ports.
             */
            portLevelSettings?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecTrafficPolicyPortLevelSettingsArgs>[]>;
            /**
             * TLS related settings for connections to the upstream service.
             */
            tls?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecTrafficPolicyTlsArgs>;
            /**
             * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
             */
            tunnel?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecTrafficPolicyTunnelArgs>;
        }

        export interface DestinationRuleSpecTrafficPolicyConnectionPoolArgs {
            /**
             * HTTP connection pool settings.
             */
            http?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecTrafficPolicyConnectionPoolHttpArgs>;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecTrafficPolicyConnectionPoolTcpArgs>;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface DestinationRuleSpecTrafficPolicyConnectionPoolHttpArgs {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: pulumi.Input<string>;
            /**
             * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
             */
            http1MaxPendingRequests?: pulumi.Input<number>;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: pulumi.Input<number>;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: pulumi.Input<string>;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            /**
             * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
             */
            maxRetries?: pulumi.Input<number>;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: pulumi.Input<boolean>;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface DestinationRuleSpecTrafficPolicyConnectionPoolTcpArgs {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepaliveArgs>;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepaliveArgs {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: pulumi.Input<string>;
            /**
             * Maximum number of keepalive probes to send without response before deciding the connection is dead.
             */
            probes?: pulumi.Input<number>;
            /**
             * The time duration a connection needs to be idle before keep-alive probes start being sent.
             */
            time?: pulumi.Input<string>;
        }

        export interface DestinationRuleSpecTrafficPolicyOutlierDetectionArgs {
            /**
             * Minimum ejection duration.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Number of 5xx errors before a host is ejected from the connection pool.
             */
            consecutive5xxErrors?: pulumi.Input<number>;
            consecutiveErrors?: pulumi.Input<number>;
            /**
             * Number of gateway errors before a host is ejected from the connection pool.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            /**
             * The number of consecutive locally originated failures before ejection occurs.
             */
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Time interval between ejection sweep analysis.
             */
            interval?: pulumi.Input<string>;
            /**
             * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
             */
            maxEjectionPercent?: pulumi.Input<number>;
            /**
             * Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode.
             */
            minHealthPercent?: pulumi.Input<number>;
            /**
             * Determines whether to distinguish local origin failures from external errors.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }

        export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsArgs {
            connectionPool?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolArgs>;
            /**
             * Settings controlling the load balancer algorithms.
             */
            loadBalancer?: any;
            outlierDetection?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetectionArgs>;
            /**
             * Specifies the number of a port on the destination service on which this policy is being applied.
             */
            port?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecTrafficPolicyPortLevelSettingsPortArgs>;
            /**
             * TLS related settings for connections to the upstream service.
             */
            tls?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecTrafficPolicyPortLevelSettingsTlsArgs>;
        }

        export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolArgs {
            /**
             * HTTP connection pool settings.
             */
            http?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttpArgs>;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpArgs>;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttpArgs {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: pulumi.Input<string>;
            /**
             * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
             */
            http1MaxPendingRequests?: pulumi.Input<number>;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: pulumi.Input<number>;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: pulumi.Input<string>;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            /**
             * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
             */
            maxRetries?: pulumi.Input<number>;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: pulumi.Input<boolean>;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpArgs {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: pulumi.Input<inputs.networking.v1alpha3.DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepaliveArgs>;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepaliveArgs {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: pulumi.Input<string>;
            /**
             * Maximum number of keepalive probes to send without response before deciding the connection is dead.
             */
            probes?: pulumi.Input<number>;
            /**
             * The time duration a connection needs to be idle before keep-alive probes start being sent.
             */
            time?: pulumi.Input<string>;
        }

        export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetectionArgs {
            /**
             * Minimum ejection duration.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Number of 5xx errors before a host is ejected from the connection pool.
             */
            consecutive5xxErrors?: pulumi.Input<number>;
            consecutiveErrors?: pulumi.Input<number>;
            /**
             * Number of gateway errors before a host is ejected from the connection pool.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            /**
             * The number of consecutive locally originated failures before ejection occurs.
             */
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Time interval between ejection sweep analysis.
             */
            interval?: pulumi.Input<string>;
            /**
             * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
             */
            maxEjectionPercent?: pulumi.Input<number>;
            /**
             * Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode.
             */
            minHealthPercent?: pulumi.Input<number>;
            /**
             * Determines whether to distinguish local origin failures from external errors.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }

        /**
         * Specifies the number of a port on the destination service on which this policy is being applied.
         */
        export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsPortArgs {
            number?: pulumi.Input<number>;
        }

        /**
         * TLS related settings for connections to the upstream service.
         */
        export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsTlsArgs {
            /**
             * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
             */
            caCertificates?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            clientCertificate?: pulumi.Input<string>;
            /**
             * The name of the secret that holds the TLS certs for the client including the CA certificates.
             */
            credentialName?: pulumi.Input<string>;
            /**
             * InsecureSkipVerify specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
             */
            insecureSkipVerify?: pulumi.Input<boolean>;
            /**
             * Indicates whether connections to this port should be secured using TLS.
             */
            mode?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            privateKey?: pulumi.Input<string>;
            /**
             * SNI string to present to the server during TLS handshake.
             */
            sni?: pulumi.Input<string>;
            /**
             * A list of alternate names to verify the subject identity in the certificate.
             */
            subjectAltNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * TLS related settings for connections to the upstream service.
         */
        export interface DestinationRuleSpecTrafficPolicyTlsArgs {
            /**
             * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
             */
            caCertificates?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            clientCertificate?: pulumi.Input<string>;
            /**
             * The name of the secret that holds the TLS certs for the client including the CA certificates.
             */
            credentialName?: pulumi.Input<string>;
            /**
             * InsecureSkipVerify specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
             */
            insecureSkipVerify?: pulumi.Input<boolean>;
            /**
             * Indicates whether connections to this port should be secured using TLS.
             */
            mode?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            privateKey?: pulumi.Input<string>;
            /**
             * SNI string to present to the server during TLS handshake.
             */
            sni?: pulumi.Input<string>;
            /**
             * A list of alternate names to verify the subject identity in the certificate.
             */
            subjectAltNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
         */
        export interface DestinationRuleSpecTrafficPolicyTunnelArgs {
            /**
             * Specifies which protocol to use for tunneling the downstream connection.
             */
            protocol?: pulumi.Input<string>;
            /**
             * Specifies a host to which the downstream connection is tunneled.
             */
            targetHost: pulumi.Input<string>;
            /**
             * Specifies a port to which the downstream connection is tunneled.
             */
            targetPort: pulumi.Input<number>;
        }

        /**
         * Criteria used to select the specific set of pods/VMs on which this `DestinationRule` configuration should be applied.
         */
        export interface DestinationRuleSpecWorkloadSelectorArgs {
            /**
             * One or more labels that indicate a specific set of pods/VMs on which a policy should be applied.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Customizing Envoy configuration generated by Istio. See more details at: https://istio.io/docs/reference/config/networking/envoy-filter.html
         */
        export interface EnvoyFilterSpecArgs {
            /**
             * One or more patches with match conditions.
             */
            configPatches?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.EnvoyFilterSpecConfigPatchesArgs>[]>;
            /**
             * Priority defines the order in which patch sets are applied within a context.
             */
            priority?: pulumi.Input<number>;
            /**
             * Criteria used to select the specific set of pods/VMs on which this patch configuration should be applied.
             */
            workloadSelector?: pulumi.Input<inputs.networking.v1alpha3.EnvoyFilterSpecWorkloadSelectorArgs>;
        }

        export interface EnvoyFilterSpecConfigPatchesArgs {
            /**
             * Specifies where in the Envoy configuration, the patch should be applied.
             */
            applyTo?: pulumi.Input<string>;
            /**
             * Match on listener/route configuration/cluster.
             */
            match?: any;
            /**
             * The patch to apply along with the operation.
             */
            patch?: pulumi.Input<inputs.networking.v1alpha3.EnvoyFilterSpecConfigPatchesPatchArgs>;
        }

        /**
         * The patch to apply along with the operation.
         */
        export interface EnvoyFilterSpecConfigPatchesPatchArgs {
            /**
             * Determines the filter insertion order.
             */
            filterClass?: pulumi.Input<string>;
            /**
             * Determines how the patch should be applied.
             */
            operation?: pulumi.Input<string>;
            /**
             * The JSON config of the object being patched.
             */
            value?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Criteria used to select the specific set of pods/VMs on which this patch configuration should be applied.
         */
        export interface EnvoyFilterSpecWorkloadSelectorArgs {
            /**
             * One or more labels that indicate a specific set of pods/VMs on which the configuration should be applied.
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Configuration affecting edge load balancer. See more details at: https://istio.io/docs/reference/config/networking/gateway.html
         */
        export interface GatewaySpecArgs {
            /**
             * One or more labels that indicate a specific set of pods/VMs on which this gateway configuration should be applied.
             */
            selector?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * A list of server specifications.
             */
            servers?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.GatewaySpecServersArgs>[]>;
        }

        export interface GatewaySpecServersArgs {
            /**
             * The ip or the Unix domain socket to which the listener should be bound to.
             */
            bind?: pulumi.Input<string>;
            defaultEndpoint?: pulumi.Input<string>;
            /**
             * One or more hosts exposed by this gateway.
             */
            hosts: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * An optional name of the server, when set must be unique across all servers.
             */
            name?: pulumi.Input<string>;
            /**
             * The Port on which the proxy should listen for incoming connections.
             */
            port: pulumi.Input<inputs.networking.v1alpha3.GatewaySpecServersPortArgs>;
            /**
             * Set of TLS related options that govern the server's behavior.
             */
            tls?: pulumi.Input<inputs.networking.v1alpha3.GatewaySpecServersTlsArgs>;
        }

        /**
         * The Port on which the proxy should listen for incoming connections.
         */
        export interface GatewaySpecServersPortArgs {
            /**
             * Label assigned to the port.
             */
            name: pulumi.Input<string>;
            /**
             * A valid non-negative integer port number.
             */
            number: pulumi.Input<number>;
            /**
             * The protocol exposed on the port.
             */
            protocol: pulumi.Input<string>;
            targetPort?: pulumi.Input<number>;
        }

        /**
         * Set of TLS related options that govern the server's behavior.
         */
        export interface GatewaySpecServersTlsArgs {
            /**
             * REQUIRED if mode is `MUTUAL` or `OPTIONAL_MUTUAL`.
             */
            caCertificates?: pulumi.Input<string>;
            /**
             * Optional: If specified, only support the specified cipher list.
             */
            cipherSuites?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * For gateways running on Kubernetes, the name of the secret that holds the TLS certs including the CA certificates.
             */
            credentialName?: pulumi.Input<string>;
            /**
             * If set to true, the load balancer will send a 301 redirect for all http connections, asking the clients to use HTTPS.
             */
            httpsRedirect?: pulumi.Input<boolean>;
            /**
             * Optional: Maximum TLS protocol version.
             */
            maxProtocolVersion?: pulumi.Input<string>;
            /**
             * Optional: Minimum TLS protocol version.
             */
            minProtocolVersion?: pulumi.Input<string>;
            /**
             * Optional: Indicates whether connections to this port should be secured using TLS.
             */
            mode?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
             */
            privateKey?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
             */
            serverCertificate?: pulumi.Input<string>;
            /**
             * A list of alternate names to verify the subject identity in the certificate presented by the client.
             */
            subjectAltNames?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * An optional list of hex-encoded SHA-256 hashes of the authorized client certificates.
             */
            verifyCertificateHash?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * An optional list of base64-encoded SHA-256 hashes of the SPKIs of authorized client certificates.
             */
            verifyCertificateSpki?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Configuration affecting service registry. See more details at: https://istio.io/docs/reference/config/networking/service-entry.html
         */
        export interface ServiceEntrySpecArgs {
            /**
             * The virtual IP addresses associated with the service.
             */
            addresses?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * One or more endpoints associated with the service.
             */
            endpoints?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.ServiceEntrySpecEndpointsArgs>[]>;
            /**
             * A list of namespaces to which this service is exported.
             */
            exportTo?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * The hosts associated with the ServiceEntry.
             */
            hosts: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Specify whether the service should be considered external to the mesh or part of the mesh.
             */
            location?: pulumi.Input<string>;
            /**
             * The ports associated with the external service.
             */
            ports?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.ServiceEntrySpecPortsArgs>[]>;
            /**
             * Service resolution mode for the hosts.
             */
            resolution?: pulumi.Input<string>;
            /**
             * If specified, the proxy will verify that the server certificate's subject alternate name matches one of the specified values.
             */
            subjectAltNames?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Applicable only for MESH_INTERNAL services.
             */
            workloadSelector?: pulumi.Input<inputs.networking.v1alpha3.ServiceEntrySpecWorkloadSelectorArgs>;
        }

        export interface ServiceEntrySpecEndpointsArgs {
            /**
             * Address associated with the network endpoint without the port.
             */
            address?: pulumi.Input<string>;
            /**
             * One or more labels associated with the endpoint.
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * The locality associated with the endpoint.
             */
            locality?: pulumi.Input<string>;
            /**
             * Network enables Istio to group endpoints resident in the same L3 domain/network.
             */
            network?: pulumi.Input<string>;
            /**
             * Set of ports associated with the endpoint.
             */
            ports?: pulumi.Input<{[key: string]: pulumi.Input<number>}>;
            /**
             * The service account associated with the workload if a sidecar is present in the workload.
             */
            serviceAccount?: pulumi.Input<string>;
            /**
             * The load balancing weight associated with the endpoint.
             */
            weight?: pulumi.Input<number>;
        }

        export interface ServiceEntrySpecPortsArgs {
            /**
             * Label assigned to the port.
             */
            name: pulumi.Input<string>;
            /**
             * A valid non-negative integer port number.
             */
            number: pulumi.Input<number>;
            /**
             * The protocol exposed on the port.
             */
            protocol?: pulumi.Input<string>;
            /**
             * The port number on the endpoint where the traffic will be received.
             */
            targetPort?: pulumi.Input<number>;
        }

        /**
         * Applicable only for MESH_INTERNAL services.
         */
        export interface ServiceEntrySpecWorkloadSelectorArgs {
            /**
             * One or more labels that indicate a specific set of pods/VMs on which the configuration should be applied.
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Configuration affecting network reachability of a sidecar. See more details at: https://istio.io/docs/reference/config/networking/sidecar.html
         */
        export interface SidecarSpecArgs {
            /**
             * Egress specifies the configuration of the sidecar for processing outbound traffic from the attached workload instance to other services in the mesh.
             */
            egress?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.SidecarSpecEgressArgs>[]>;
            /**
             * Settings controlling the volume of connections Envoy will accept from the network.
             */
            inboundConnectionPool?: pulumi.Input<inputs.networking.v1alpha3.SidecarSpecInboundConnectionPoolArgs>;
            /**
             * Ingress specifies the configuration of the sidecar for processing inbound traffic to the attached workload instance.
             */
            ingress?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.SidecarSpecIngressArgs>[]>;
            /**
             * Configuration for the outbound traffic policy.
             */
            outboundTrafficPolicy?: pulumi.Input<inputs.networking.v1alpha3.SidecarSpecOutboundTrafficPolicyArgs>;
            /**
             * Criteria used to select the specific set of pods/VMs on which this `Sidecar` configuration should be applied.
             */
            workloadSelector?: pulumi.Input<inputs.networking.v1alpha3.SidecarSpecWorkloadSelectorArgs>;
        }

        export interface SidecarSpecEgressArgs {
            /**
             * The IP(IPv4 or IPv6) or the Unix domain socket to which the listener should be bound to.
             */
            bind?: pulumi.Input<string>;
            /**
             * When the bind address is an IP, the captureMode option dictates how traffic to the listener is expected to be captured (or not).
             */
            captureMode?: pulumi.Input<string>;
            /**
             * One or more service hosts exposed by the listener in `namespace/dnsName` format.
             */
            hosts: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * The port associated with the listener.
             */
            port?: pulumi.Input<inputs.networking.v1alpha3.SidecarSpecEgressPortArgs>;
        }

        /**
         * The port associated with the listener.
         */
        export interface SidecarSpecEgressPortArgs {
            /**
             * Label assigned to the port.
             */
            name?: pulumi.Input<string>;
            /**
             * A valid non-negative integer port number.
             */
            number?: pulumi.Input<number>;
            /**
             * The protocol exposed on the port.
             */
            protocol?: pulumi.Input<string>;
            targetPort?: pulumi.Input<number>;
        }

        /**
         * Settings controlling the volume of connections Envoy will accept from the network.
         */
        export interface SidecarSpecInboundConnectionPoolArgs {
            /**
             * HTTP connection pool settings.
             */
            http?: pulumi.Input<inputs.networking.v1alpha3.SidecarSpecInboundConnectionPoolHttpArgs>;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: pulumi.Input<inputs.networking.v1alpha3.SidecarSpecInboundConnectionPoolTcpArgs>;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface SidecarSpecInboundConnectionPoolHttpArgs {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: pulumi.Input<string>;
            /**
             * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
             */
            http1MaxPendingRequests?: pulumi.Input<number>;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: pulumi.Input<number>;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: pulumi.Input<string>;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            /**
             * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
             */
            maxRetries?: pulumi.Input<number>;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: pulumi.Input<boolean>;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface SidecarSpecInboundConnectionPoolTcpArgs {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: pulumi.Input<inputs.networking.v1alpha3.SidecarSpecInboundConnectionPoolTcpTcpKeepaliveArgs>;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface SidecarSpecInboundConnectionPoolTcpTcpKeepaliveArgs {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: pulumi.Input<string>;
            /**
             * Maximum number of keepalive probes to send without response before deciding the connection is dead.
             */
            probes?: pulumi.Input<number>;
            /**
             * The time duration a connection needs to be idle before keep-alive probes start being sent.
             */
            time?: pulumi.Input<string>;
        }

        export interface SidecarSpecIngressArgs {
            /**
             * The IP(IPv4 or IPv6) to which the listener should be bound.
             */
            bind?: pulumi.Input<string>;
            /**
             * The captureMode option dictates how traffic to the listener is expected to be captured (or not).
             */
            captureMode?: pulumi.Input<string>;
            /**
             * Settings controlling the volume of connections Envoy will accept from the network.
             */
            connectionPool?: pulumi.Input<inputs.networking.v1alpha3.SidecarSpecIngressConnectionPoolArgs>;
            /**
             * The IP endpoint or Unix domain socket to which traffic should be forwarded to.
             */
            defaultEndpoint?: pulumi.Input<string>;
            /**
             * The port associated with the listener.
             */
            port: pulumi.Input<inputs.networking.v1alpha3.SidecarSpecIngressPortArgs>;
            /**
             * Set of TLS related options that will enable TLS termination on the sidecar for requests originating from outside the mesh.
             */
            tls?: pulumi.Input<inputs.networking.v1alpha3.SidecarSpecIngressTlsArgs>;
        }

        /**
         * Settings controlling the volume of connections Envoy will accept from the network.
         */
        export interface SidecarSpecIngressConnectionPoolArgs {
            /**
             * HTTP connection pool settings.
             */
            http?: pulumi.Input<inputs.networking.v1alpha3.SidecarSpecIngressConnectionPoolHttpArgs>;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: pulumi.Input<inputs.networking.v1alpha3.SidecarSpecIngressConnectionPoolTcpArgs>;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface SidecarSpecIngressConnectionPoolHttpArgs {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: pulumi.Input<string>;
            /**
             * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
             */
            http1MaxPendingRequests?: pulumi.Input<number>;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: pulumi.Input<number>;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: pulumi.Input<string>;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            /**
             * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
             */
            maxRetries?: pulumi.Input<number>;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: pulumi.Input<boolean>;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface SidecarSpecIngressConnectionPoolTcpArgs {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: pulumi.Input<inputs.networking.v1alpha3.SidecarSpecIngressConnectionPoolTcpTcpKeepaliveArgs>;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface SidecarSpecIngressConnectionPoolTcpTcpKeepaliveArgs {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: pulumi.Input<string>;
            /**
             * Maximum number of keepalive probes to send without response before deciding the connection is dead.
             */
            probes?: pulumi.Input<number>;
            /**
             * The time duration a connection needs to be idle before keep-alive probes start being sent.
             */
            time?: pulumi.Input<string>;
        }

        /**
         * The port associated with the listener.
         */
        export interface SidecarSpecIngressPortArgs {
            /**
             * Label assigned to the port.
             */
            name?: pulumi.Input<string>;
            /**
             * A valid non-negative integer port number.
             */
            number?: pulumi.Input<number>;
            /**
             * The protocol exposed on the port.
             */
            protocol?: pulumi.Input<string>;
            targetPort?: pulumi.Input<number>;
        }

        /**
         * Set of TLS related options that will enable TLS termination on the sidecar for requests originating from outside the mesh.
         */
        export interface SidecarSpecIngressTlsArgs {
            /**
             * REQUIRED if mode is `MUTUAL` or `OPTIONAL_MUTUAL`.
             */
            caCertificates?: pulumi.Input<string>;
            /**
             * Optional: If specified, only support the specified cipher list.
             */
            cipherSuites?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * For gateways running on Kubernetes, the name of the secret that holds the TLS certs including the CA certificates.
             */
            credentialName?: pulumi.Input<string>;
            /**
             * If set to true, the load balancer will send a 301 redirect for all http connections, asking the clients to use HTTPS.
             */
            httpsRedirect?: pulumi.Input<boolean>;
            /**
             * Optional: Maximum TLS protocol version.
             */
            maxProtocolVersion?: pulumi.Input<string>;
            /**
             * Optional: Minimum TLS protocol version.
             */
            minProtocolVersion?: pulumi.Input<string>;
            /**
             * Optional: Indicates whether connections to this port should be secured using TLS.
             */
            mode?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
             */
            privateKey?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
             */
            serverCertificate?: pulumi.Input<string>;
            /**
             * A list of alternate names to verify the subject identity in the certificate presented by the client.
             */
            subjectAltNames?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * An optional list of hex-encoded SHA-256 hashes of the authorized client certificates.
             */
            verifyCertificateHash?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * An optional list of base64-encoded SHA-256 hashes of the SPKIs of authorized client certificates.
             */
            verifyCertificateSpki?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Configuration for the outbound traffic policy.
         */
        export interface SidecarSpecOutboundTrafficPolicyArgs {
            egressProxy?: pulumi.Input<inputs.networking.v1alpha3.SidecarSpecOutboundTrafficPolicyEgressProxyArgs>;
            mode?: pulumi.Input<string>;
        }

        export interface SidecarSpecOutboundTrafficPolicyEgressProxyArgs {
            /**
             * The name of a service from the service registry.
             */
            host: pulumi.Input<string>;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: pulumi.Input<inputs.networking.v1alpha3.SidecarSpecOutboundTrafficPolicyEgressProxyPortArgs>;
            /**
             * The name of a subset within the service.
             */
            subset?: pulumi.Input<string>;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface SidecarSpecOutboundTrafficPolicyEgressProxyPortArgs {
            number?: pulumi.Input<number>;
        }

        /**
         * Criteria used to select the specific set of pods/VMs on which this `Sidecar` configuration should be applied.
         */
        export interface SidecarSpecWorkloadSelectorArgs {
            /**
             * One or more labels that indicate a specific set of pods/VMs on which the configuration should be applied.
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Configuration affecting label/content routing, sni routing, etc. See more details at: https://istio.io/docs/reference/config/networking/virtual-service.html
         */
        export interface VirtualServiceSpecArgs {
            /**
             * A list of namespaces to which this virtual service is exported.
             */
            exportTo?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * The names of gateways and sidecars that should apply these routes.
             */
            gateways?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * The destination hosts to which traffic is being sent.
             */
            hosts?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * An ordered list of route rules for HTTP traffic.
             */
            http?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpArgs>[]>;
            /**
             * An ordered list of route rules for opaque TCP traffic.
             */
            tcp?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecTcpArgs>[]>;
            /**
             * An ordered list of route rule for non-terminated TLS & HTTPS traffic.
             */
            tls?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecTlsArgs>[]>;
        }

        export interface VirtualServiceSpecHttpArgs {
            /**
             * Cross-Origin Resource Sharing policy (CORS).
             */
            corsPolicy?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpCorsPolicyArgs>;
            /**
             * Delegate is used to specify the particular VirtualService which can be used to define delegate HTTPRoute.
             */
            delegate?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpDelegateArgs>;
            /**
             * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
             */
            directResponse?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpDirectResponseArgs>;
            /**
             * Fault injection policy to apply on HTTP traffic at the client side.
             */
            fault?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpFaultArgs>;
            headers?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpHeadersArgs>;
            /**
             * Match conditions to be satisfied for the rule to be activated.
             */
            match?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpMatchArgs>[]>;
            /**
             * Mirror HTTP traffic to a another destination in addition to forwarding the requests to the intended destination.
             */
            mirror?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpMirrorArgs>;
            mirrorPercent?: pulumi.Input<number>;
            /**
             * Percentage of the traffic to be mirrored by the `mirror` field.
             */
            mirrorPercentage?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpMirrorPercentageArgs>;
            mirror_percent?: pulumi.Input<number>;
            /**
             * Specifies the destinations to mirror HTTP traffic in addition to the original destination.
             */
            mirrors?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpMirrorsArgs>[]>;
            /**
             * The name assigned to the route for debugging purposes.
             */
            name?: pulumi.Input<string>;
            /**
             * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
             */
            redirect?: any;
            /**
             * Retry policy for HTTP requests.
             */
            retries?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpRetriesArgs>;
            /**
             * Rewrite HTTP URIs and Authority headers.
             */
            rewrite?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpRewriteArgs>;
            /**
             * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
             */
            route?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpRouteArgs>[]>;
            /**
             * Timeout for HTTP requests, default is disabled.
             */
            timeout?: pulumi.Input<string>;
        }

        /**
         * Cross-Origin Resource Sharing policy (CORS).
         */
        export interface VirtualServiceSpecHttpCorsPolicyArgs {
            /**
             * Indicates whether the caller is allowed to send the actual request (not the preflight) using credentials.
             */
            allowCredentials?: pulumi.Input<boolean>;
            /**
             * List of HTTP headers that can be used when requesting the resource.
             */
            allowHeaders?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * List of HTTP methods allowed to access the resource.
             */
            allowMethods?: pulumi.Input<pulumi.Input<string>[]>;
            allowOrigin?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * String patterns that match allowed origins.
             */
            allowOrigins?: pulumi.Input<any[]>;
            /**
             * A list of HTTP headers that the browsers are allowed to access.
             */
            exposeHeaders?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Specifies how long the results of a preflight request can be cached.
             */
            maxAge?: pulumi.Input<string>;
        }

        /**
         * Delegate is used to specify the particular VirtualService which can be used to define delegate HTTPRoute.
         */
        export interface VirtualServiceSpecHttpDelegateArgs {
            /**
             * Name specifies the name of the delegate VirtualService.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace specifies the namespace where the delegate VirtualService resides.
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
         */
        export interface VirtualServiceSpecHttpDirectResponseArgs {
            /**
             * Specifies the content of the response body.
             */
            body?: any;
            /**
             * Specifies the HTTP response status to be returned.
             */
            status: pulumi.Input<number>;
        }

        /**
         * Fault injection policy to apply on HTTP traffic at the client side.
         */
        export interface VirtualServiceSpecHttpFaultArgs {
            /**
             * Abort Http request attempts and return error codes back to downstream service, giving the impression that the upstream service is faulty.
             */
            abort?: any;
            /**
             * Delay requests before forwarding, emulating various failures such as network issues, overloaded upstream service, etc.
             */
            delay?: any;
        }

        export interface VirtualServiceSpecHttpHeadersArgs {
            request?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpHeadersRequestArgs>;
            response?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpHeadersResponseArgs>;
        }

        export interface VirtualServiceSpecHttpHeadersRequestArgs {
            add?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            remove?: pulumi.Input<pulumi.Input<string>[]>;
            set?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface VirtualServiceSpecHttpHeadersResponseArgs {
            add?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            remove?: pulumi.Input<pulumi.Input<string>[]>;
            set?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface VirtualServiceSpecHttpMatchArgs {
            /**
             * HTTP Authority values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
             */
            authority?: any;
            /**
             * Names of gateways where the rule should be applied.
             */
            gateways?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * The header keys must be lowercase and use hyphen as the separator, e.g.
             */
            headers?: pulumi.Input<{[key: string]: any}>;
            /**
             * Flag to specify whether the URI matching should be case-insensitive.
             */
            ignoreUriCase?: pulumi.Input<boolean>;
            /**
             * HTTP Method values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
             */
            method?: any;
            /**
             * The name assigned to a match.
             */
            name?: pulumi.Input<string>;
            /**
             * Specifies the ports on the host that is being addressed.
             */
            port?: pulumi.Input<number>;
            /**
             * Query parameters for matching.
             */
            queryParams?: pulumi.Input<{[key: string]: any}>;
            /**
             * URI Scheme values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
             */
            scheme?: any;
            /**
             * One or more labels that constrain the applicability of a rule to source (client) workloads with the given labels.
             */
            sourceLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Source namespace constraining the applicability of a rule to workloads in that namespace.
             */
            sourceNamespace?: pulumi.Input<string>;
            /**
             * The human readable prefix to use when emitting statistics for this route.
             */
            statPrefix?: pulumi.Input<string>;
            /**
             * URI to match values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
             */
            uri?: any;
            /**
             * withoutHeader has the same syntax with the header, but has opposite meaning.
             */
            withoutHeaders?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Mirror HTTP traffic to a another destination in addition to forwarding the requests to the intended destination.
         */
        export interface VirtualServiceSpecHttpMirrorArgs {
            /**
             * The name of a service from the service registry.
             */
            host: pulumi.Input<string>;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpMirrorPortArgs>;
            /**
             * The name of a subset within the service.
             */
            subset?: pulumi.Input<string>;
        }

        /**
         * Percentage of the traffic to be mirrored by the `mirror` field.
         */
        export interface VirtualServiceSpecHttpMirrorPercentageArgs {
            value?: pulumi.Input<number>;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecHttpMirrorPortArgs {
            number?: pulumi.Input<number>;
        }

        export interface VirtualServiceSpecHttpMirrorsArgs {
            /**
             * Destination specifies the target of the mirror operation.
             */
            destination: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpMirrorsDestinationArgs>;
            /**
             * Percentage of the traffic to be mirrored by the `destination` field.
             */
            percentage?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpMirrorsPercentageArgs>;
        }

        /**
         * Destination specifies the target of the mirror operation.
         */
        export interface VirtualServiceSpecHttpMirrorsDestinationArgs {
            /**
             * The name of a service from the service registry.
             */
            host: pulumi.Input<string>;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpMirrorsDestinationPortArgs>;
            /**
             * The name of a subset within the service.
             */
            subset?: pulumi.Input<string>;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecHttpMirrorsDestinationPortArgs {
            number?: pulumi.Input<number>;
        }

        /**
         * Percentage of the traffic to be mirrored by the `destination` field.
         */
        export interface VirtualServiceSpecHttpMirrorsPercentageArgs {
            value?: pulumi.Input<number>;
        }

        /**
         * Retry policy for HTTP requests.
         */
        export interface VirtualServiceSpecHttpRetriesArgs {
            /**
             * Number of retries to be allowed for a given request.
             */
            attempts?: pulumi.Input<number>;
            /**
             * Timeout per attempt for a given request, including the initial call and any retries.
             */
            perTryTimeout?: pulumi.Input<string>;
            /**
             * Specifies the conditions under which retry takes place.
             */
            retryOn?: pulumi.Input<string>;
            /**
             * Flag to specify whether the retries should retry to other localities.
             */
            retryRemoteLocalities?: pulumi.Input<boolean>;
        }

        /**
         * Rewrite HTTP URIs and Authority headers.
         */
        export interface VirtualServiceSpecHttpRewriteArgs {
            /**
             * rewrite the Authority/Host header with this value.
             */
            authority?: pulumi.Input<string>;
            /**
             * rewrite the path (or the prefix) portion of the URI with this value.
             */
            uri?: pulumi.Input<string>;
            /**
             * rewrite the path portion of the URI with the specified regex.
             */
            uriRegexRewrite?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpRewriteUriRegexRewriteArgs>;
        }

        /**
         * rewrite the path portion of the URI with the specified regex.
         */
        export interface VirtualServiceSpecHttpRewriteUriRegexRewriteArgs {
            /**
             * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
             */
            match?: pulumi.Input<string>;
            /**
             * The string that should replace into matching portions of original URI.
             */
            rewrite?: pulumi.Input<string>;
        }

        export interface VirtualServiceSpecHttpRouteArgs {
            /**
             * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
             */
            destination: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpRouteDestinationArgs>;
            headers?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpRouteHeadersArgs>;
            /**
             * Weight specifies the relative proportion of traffic to be forwarded to the destination.
             */
            weight?: pulumi.Input<number>;
        }

        /**
         * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
         */
        export interface VirtualServiceSpecHttpRouteDestinationArgs {
            /**
             * The name of a service from the service registry.
             */
            host: pulumi.Input<string>;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpRouteDestinationPortArgs>;
            /**
             * The name of a subset within the service.
             */
            subset?: pulumi.Input<string>;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecHttpRouteDestinationPortArgs {
            number?: pulumi.Input<number>;
        }

        export interface VirtualServiceSpecHttpRouteHeadersArgs {
            request?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpRouteHeadersRequestArgs>;
            response?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecHttpRouteHeadersResponseArgs>;
        }

        export interface VirtualServiceSpecHttpRouteHeadersRequestArgs {
            add?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            remove?: pulumi.Input<pulumi.Input<string>[]>;
            set?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface VirtualServiceSpecHttpRouteHeadersResponseArgs {
            add?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            remove?: pulumi.Input<pulumi.Input<string>[]>;
            set?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface VirtualServiceSpecTcpArgs {
            /**
             * Match conditions to be satisfied for the rule to be activated.
             */
            match?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecTcpMatchArgs>[]>;
            /**
             * The destination to which the connection should be forwarded to.
             */
            route?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecTcpRouteArgs>[]>;
        }

        export interface VirtualServiceSpecTcpMatchArgs {
            /**
             * IPv4 or IPv6 ip addresses of destination with optional subnet.
             */
            destinationSubnets?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Names of gateways where the rule should be applied.
             */
            gateways?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: pulumi.Input<number>;
            /**
             * One or more labels that constrain the applicability of a rule to workloads with the given labels.
             */
            sourceLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Source namespace constraining the applicability of a rule to workloads in that namespace.
             */
            sourceNamespace?: pulumi.Input<string>;
            sourceSubnet?: pulumi.Input<string>;
        }

        export interface VirtualServiceSpecTcpRouteArgs {
            /**
             * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
             */
            destination: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecTcpRouteDestinationArgs>;
            /**
             * Weight specifies the relative proportion of traffic to be forwarded to the destination.
             */
            weight?: pulumi.Input<number>;
        }

        /**
         * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
         */
        export interface VirtualServiceSpecTcpRouteDestinationArgs {
            /**
             * The name of a service from the service registry.
             */
            host: pulumi.Input<string>;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecTcpRouteDestinationPortArgs>;
            /**
             * The name of a subset within the service.
             */
            subset?: pulumi.Input<string>;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecTcpRouteDestinationPortArgs {
            number?: pulumi.Input<number>;
        }

        export interface VirtualServiceSpecTlsArgs {
            /**
             * Match conditions to be satisfied for the rule to be activated.
             */
            match: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecTlsMatchArgs>[]>;
            /**
             * The destination to which the connection should be forwarded to.
             */
            route?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecTlsRouteArgs>[]>;
        }

        export interface VirtualServiceSpecTlsMatchArgs {
            /**
             * IPv4 or IPv6 ip addresses of destination with optional subnet.
             */
            destinationSubnets?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Names of gateways where the rule should be applied.
             */
            gateways?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: pulumi.Input<number>;
            /**
             * SNI (server name indicator) to match on.
             */
            sniHosts: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * One or more labels that constrain the applicability of a rule to workloads with the given labels.
             */
            sourceLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Source namespace constraining the applicability of a rule to workloads in that namespace.
             */
            sourceNamespace?: pulumi.Input<string>;
        }

        export interface VirtualServiceSpecTlsRouteArgs {
            /**
             * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
             */
            destination: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecTlsRouteDestinationArgs>;
            /**
             * Weight specifies the relative proportion of traffic to be forwarded to the destination.
             */
            weight?: pulumi.Input<number>;
        }

        /**
         * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
         */
        export interface VirtualServiceSpecTlsRouteDestinationArgs {
            /**
             * The name of a service from the service registry.
             */
            host: pulumi.Input<string>;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: pulumi.Input<inputs.networking.v1alpha3.VirtualServiceSpecTlsRouteDestinationPortArgs>;
            /**
             * The name of a subset within the service.
             */
            subset?: pulumi.Input<string>;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecTlsRouteDestinationPortArgs {
            number?: pulumi.Input<number>;
        }

        /**
         * Configuration affecting VMs onboarded into the mesh. See more details at: https://istio.io/docs/reference/config/networking/workload-entry.html
         */
        export interface WorkloadEntrySpecArgs {
            /**
             * Address associated with the network endpoint without the port.
             */
            address?: pulumi.Input<string>;
            /**
             * One or more labels associated with the endpoint.
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * The locality associated with the endpoint.
             */
            locality?: pulumi.Input<string>;
            /**
             * Network enables Istio to group endpoints resident in the same L3 domain/network.
             */
            network?: pulumi.Input<string>;
            /**
             * Set of ports associated with the endpoint.
             */
            ports?: pulumi.Input<{[key: string]: pulumi.Input<number>}>;
            /**
             * The service account associated with the workload if a sidecar is present in the workload.
             */
            serviceAccount?: pulumi.Input<string>;
            /**
             * The load balancing weight associated with the endpoint.
             */
            weight?: pulumi.Input<number>;
        }

        /**
         * Describes a collection of workload instances. See more details at: https://istio.io/docs/reference/config/networking/workload-group.html
         */
        export interface WorkloadGroupSpecArgs {
            /**
             * Metadata that will be used for all corresponding `WorkloadEntries`.
             */
            metadata?: pulumi.Input<inputs.networking.v1alpha3.WorkloadGroupSpecMetadataArgs>;
            /**
             * `ReadinessProbe` describes the configuration the user must provide for healthchecking on their workload.
             */
            probe?: any;
            /**
             * Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
             */
            template: pulumi.Input<inputs.networking.v1alpha3.WorkloadGroupSpecTemplateArgs>;
        }

        /**
         * Metadata that will be used for all corresponding `WorkloadEntries`.
         */
        export interface WorkloadGroupSpecMetadataArgs {
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
         */
        export interface WorkloadGroupSpecTemplateArgs {
            /**
             * Address associated with the network endpoint without the port.
             */
            address?: pulumi.Input<string>;
            /**
             * One or more labels associated with the endpoint.
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * The locality associated with the endpoint.
             */
            locality?: pulumi.Input<string>;
            /**
             * Network enables Istio to group endpoints resident in the same L3 domain/network.
             */
            network?: pulumi.Input<string>;
            /**
             * Set of ports associated with the endpoint.
             */
            ports?: pulumi.Input<{[key: string]: pulumi.Input<number>}>;
            /**
             * The service account associated with the workload if a sidecar is present in the workload.
             */
            serviceAccount?: pulumi.Input<string>;
            /**
             * The load balancing weight associated with the endpoint.
             */
            weight?: pulumi.Input<number>;
        }

    }

    export namespace v1beta1 {
        /**
         * Configuration affecting load balancing, outlier detection, etc. See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html
         */
        export interface DestinationRuleSpecArgs {
            /**
             * A list of namespaces to which this destination rule is exported.
             */
            exportTo?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * The name of a service from the service registry.
             */
            host: pulumi.Input<string>;
            /**
             * One or more named sets that represent individual versions of a service.
             */
            subsets?: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecSubsetsArgs>[]>;
            /**
             * Traffic policies to apply (load balancing policy, connection pool sizes, outlier detection).
             */
            trafficPolicy?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecTrafficPolicyArgs>;
            /**
             * Criteria used to select the specific set of pods/VMs on which this `DestinationRule` configuration should be applied.
             */
            workloadSelector?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecWorkloadSelectorArgs>;
        }

        export interface DestinationRuleSpecSubsetsArgs {
            /**
             * Labels apply a filter over the endpoints of a service in the service registry.
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Name of the subset.
             */
            name: pulumi.Input<string>;
            /**
             * Traffic policies that apply to this subset.
             */
            trafficPolicy?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficPolicyArgs>;
        }

        /**
         * Traffic policies that apply to this subset.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyArgs {
            connectionPool?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolArgs>;
            /**
             * Settings controlling the load balancer algorithms.
             */
            loadBalancer?: any;
            outlierDetection?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficPolicyOutlierDetectionArgs>;
            /**
             * Traffic policies specific to individual ports.
             */
            portLevelSettings?: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsArgs>[]>;
            /**
             * TLS related settings for connections to the upstream service.
             */
            tls?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficPolicyTlsArgs>;
            /**
             * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
             */
            tunnel?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficPolicyTunnelArgs>;
        }

        export interface DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolArgs {
            /**
             * HTTP connection pool settings.
             */
            http?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttpArgs>;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpArgs>;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttpArgs {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: pulumi.Input<string>;
            /**
             * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
             */
            http1MaxPendingRequests?: pulumi.Input<number>;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: pulumi.Input<number>;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: pulumi.Input<string>;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            /**
             * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
             */
            maxRetries?: pulumi.Input<number>;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: pulumi.Input<boolean>;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpArgs {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepaliveArgs>;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepaliveArgs {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: pulumi.Input<string>;
            /**
             * Maximum number of keepalive probes to send without response before deciding the connection is dead.
             */
            probes?: pulumi.Input<number>;
            /**
             * The time duration a connection needs to be idle before keep-alive probes start being sent.
             */
            time?: pulumi.Input<string>;
        }

        export interface DestinationRuleSpecSubsetsTrafficPolicyOutlierDetectionArgs {
            /**
             * Minimum ejection duration.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Number of 5xx errors before a host is ejected from the connection pool.
             */
            consecutive5xxErrors?: pulumi.Input<number>;
            consecutiveErrors?: pulumi.Input<number>;
            /**
             * Number of gateway errors before a host is ejected from the connection pool.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            /**
             * The number of consecutive locally originated failures before ejection occurs.
             */
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Time interval between ejection sweep analysis.
             */
            interval?: pulumi.Input<string>;
            /**
             * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
             */
            maxEjectionPercent?: pulumi.Input<number>;
            /**
             * Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode.
             */
            minHealthPercent?: pulumi.Input<number>;
            /**
             * Determines whether to distinguish local origin failures from external errors.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }

        export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsArgs {
            connectionPool?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolArgs>;
            /**
             * Settings controlling the load balancer algorithms.
             */
            loadBalancer?: any;
            outlierDetection?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetectionArgs>;
            /**
             * Specifies the number of a port on the destination service on which this policy is being applied.
             */
            port?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPortArgs>;
            /**
             * TLS related settings for connections to the upstream service.
             */
            tls?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTlsArgs>;
        }

        export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolArgs {
            /**
             * HTTP connection pool settings.
             */
            http?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpArgs>;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpArgs>;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpArgs {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: pulumi.Input<string>;
            /**
             * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
             */
            http1MaxPendingRequests?: pulumi.Input<number>;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: pulumi.Input<number>;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: pulumi.Input<string>;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            /**
             * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
             */
            maxRetries?: pulumi.Input<number>;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: pulumi.Input<boolean>;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpArgs {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepaliveArgs>;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepaliveArgs {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: pulumi.Input<string>;
            /**
             * Maximum number of keepalive probes to send without response before deciding the connection is dead.
             */
            probes?: pulumi.Input<number>;
            /**
             * The time duration a connection needs to be idle before keep-alive probes start being sent.
             */
            time?: pulumi.Input<string>;
        }

        export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetectionArgs {
            /**
             * Minimum ejection duration.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Number of 5xx errors before a host is ejected from the connection pool.
             */
            consecutive5xxErrors?: pulumi.Input<number>;
            consecutiveErrors?: pulumi.Input<number>;
            /**
             * Number of gateway errors before a host is ejected from the connection pool.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            /**
             * The number of consecutive locally originated failures before ejection occurs.
             */
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Time interval between ejection sweep analysis.
             */
            interval?: pulumi.Input<string>;
            /**
             * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
             */
            maxEjectionPercent?: pulumi.Input<number>;
            /**
             * Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode.
             */
            minHealthPercent?: pulumi.Input<number>;
            /**
             * Determines whether to distinguish local origin failures from external errors.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }

        /**
         * Specifies the number of a port on the destination service on which this policy is being applied.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPortArgs {
            number?: pulumi.Input<number>;
        }

        /**
         * TLS related settings for connections to the upstream service.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTlsArgs {
            /**
             * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
             */
            caCertificates?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            clientCertificate?: pulumi.Input<string>;
            /**
             * The name of the secret that holds the TLS certs for the client including the CA certificates.
             */
            credentialName?: pulumi.Input<string>;
            /**
             * InsecureSkipVerify specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
             */
            insecureSkipVerify?: pulumi.Input<boolean>;
            /**
             * Indicates whether connections to this port should be secured using TLS.
             */
            mode?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            privateKey?: pulumi.Input<string>;
            /**
             * SNI string to present to the server during TLS handshake.
             */
            sni?: pulumi.Input<string>;
            /**
             * A list of alternate names to verify the subject identity in the certificate.
             */
            subjectAltNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * TLS related settings for connections to the upstream service.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyTlsArgs {
            /**
             * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
             */
            caCertificates?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            clientCertificate?: pulumi.Input<string>;
            /**
             * The name of the secret that holds the TLS certs for the client including the CA certificates.
             */
            credentialName?: pulumi.Input<string>;
            /**
             * InsecureSkipVerify specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
             */
            insecureSkipVerify?: pulumi.Input<boolean>;
            /**
             * Indicates whether connections to this port should be secured using TLS.
             */
            mode?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            privateKey?: pulumi.Input<string>;
            /**
             * SNI string to present to the server during TLS handshake.
             */
            sni?: pulumi.Input<string>;
            /**
             * A list of alternate names to verify the subject identity in the certificate.
             */
            subjectAltNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyTunnelArgs {
            /**
             * Specifies which protocol to use for tunneling the downstream connection.
             */
            protocol?: pulumi.Input<string>;
            /**
             * Specifies a host to which the downstream connection is tunneled.
             */
            targetHost: pulumi.Input<string>;
            /**
             * Specifies a port to which the downstream connection is tunneled.
             */
            targetPort: pulumi.Input<number>;
        }

        /**
         * Traffic policies to apply (load balancing policy, connection pool sizes, outlier detection).
         */
        export interface DestinationRuleSpecTrafficPolicyArgs {
            connectionPool?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecTrafficPolicyConnectionPoolArgs>;
            /**
             * Settings controlling the load balancer algorithms.
             */
            loadBalancer?: any;
            outlierDetection?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecTrafficPolicyOutlierDetectionArgs>;
            /**
             * Traffic policies specific to individual ports.
             */
            portLevelSettings?: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecTrafficPolicyPortLevelSettingsArgs>[]>;
            /**
             * TLS related settings for connections to the upstream service.
             */
            tls?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecTrafficPolicyTlsArgs>;
            /**
             * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
             */
            tunnel?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecTrafficPolicyTunnelArgs>;
        }

        export interface DestinationRuleSpecTrafficPolicyConnectionPoolArgs {
            /**
             * HTTP connection pool settings.
             */
            http?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecTrafficPolicyConnectionPoolHttpArgs>;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecTrafficPolicyConnectionPoolTcpArgs>;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface DestinationRuleSpecTrafficPolicyConnectionPoolHttpArgs {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: pulumi.Input<string>;
            /**
             * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
             */
            http1MaxPendingRequests?: pulumi.Input<number>;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: pulumi.Input<number>;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: pulumi.Input<string>;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            /**
             * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
             */
            maxRetries?: pulumi.Input<number>;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: pulumi.Input<boolean>;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface DestinationRuleSpecTrafficPolicyConnectionPoolTcpArgs {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepaliveArgs>;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepaliveArgs {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: pulumi.Input<string>;
            /**
             * Maximum number of keepalive probes to send without response before deciding the connection is dead.
             */
            probes?: pulumi.Input<number>;
            /**
             * The time duration a connection needs to be idle before keep-alive probes start being sent.
             */
            time?: pulumi.Input<string>;
        }

        export interface DestinationRuleSpecTrafficPolicyOutlierDetectionArgs {
            /**
             * Minimum ejection duration.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Number of 5xx errors before a host is ejected from the connection pool.
             */
            consecutive5xxErrors?: pulumi.Input<number>;
            consecutiveErrors?: pulumi.Input<number>;
            /**
             * Number of gateway errors before a host is ejected from the connection pool.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            /**
             * The number of consecutive locally originated failures before ejection occurs.
             */
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Time interval between ejection sweep analysis.
             */
            interval?: pulumi.Input<string>;
            /**
             * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
             */
            maxEjectionPercent?: pulumi.Input<number>;
            /**
             * Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode.
             */
            minHealthPercent?: pulumi.Input<number>;
            /**
             * Determines whether to distinguish local origin failures from external errors.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }

        export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsArgs {
            connectionPool?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolArgs>;
            /**
             * Settings controlling the load balancer algorithms.
             */
            loadBalancer?: any;
            outlierDetection?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetectionArgs>;
            /**
             * Specifies the number of a port on the destination service on which this policy is being applied.
             */
            port?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecTrafficPolicyPortLevelSettingsPortArgs>;
            /**
             * TLS related settings for connections to the upstream service.
             */
            tls?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecTrafficPolicyPortLevelSettingsTlsArgs>;
        }

        export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolArgs {
            /**
             * HTTP connection pool settings.
             */
            http?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttpArgs>;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpArgs>;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttpArgs {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: pulumi.Input<string>;
            /**
             * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
             */
            http1MaxPendingRequests?: pulumi.Input<number>;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: pulumi.Input<number>;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: pulumi.Input<string>;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            /**
             * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
             */
            maxRetries?: pulumi.Input<number>;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: pulumi.Input<boolean>;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpArgs {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: pulumi.Input<inputs.networking.v1beta1.DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepaliveArgs>;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepaliveArgs {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: pulumi.Input<string>;
            /**
             * Maximum number of keepalive probes to send without response before deciding the connection is dead.
             */
            probes?: pulumi.Input<number>;
            /**
             * The time duration a connection needs to be idle before keep-alive probes start being sent.
             */
            time?: pulumi.Input<string>;
        }

        export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetectionArgs {
            /**
             * Minimum ejection duration.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Number of 5xx errors before a host is ejected from the connection pool.
             */
            consecutive5xxErrors?: pulumi.Input<number>;
            consecutiveErrors?: pulumi.Input<number>;
            /**
             * Number of gateway errors before a host is ejected from the connection pool.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            /**
             * The number of consecutive locally originated failures before ejection occurs.
             */
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Time interval between ejection sweep analysis.
             */
            interval?: pulumi.Input<string>;
            /**
             * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
             */
            maxEjectionPercent?: pulumi.Input<number>;
            /**
             * Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode.
             */
            minHealthPercent?: pulumi.Input<number>;
            /**
             * Determines whether to distinguish local origin failures from external errors.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }

        /**
         * Specifies the number of a port on the destination service on which this policy is being applied.
         */
        export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsPortArgs {
            number?: pulumi.Input<number>;
        }

        /**
         * TLS related settings for connections to the upstream service.
         */
        export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsTlsArgs {
            /**
             * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
             */
            caCertificates?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            clientCertificate?: pulumi.Input<string>;
            /**
             * The name of the secret that holds the TLS certs for the client including the CA certificates.
             */
            credentialName?: pulumi.Input<string>;
            /**
             * InsecureSkipVerify specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
             */
            insecureSkipVerify?: pulumi.Input<boolean>;
            /**
             * Indicates whether connections to this port should be secured using TLS.
             */
            mode?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            privateKey?: pulumi.Input<string>;
            /**
             * SNI string to present to the server during TLS handshake.
             */
            sni?: pulumi.Input<string>;
            /**
             * A list of alternate names to verify the subject identity in the certificate.
             */
            subjectAltNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * TLS related settings for connections to the upstream service.
         */
        export interface DestinationRuleSpecTrafficPolicyTlsArgs {
            /**
             * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
             */
            caCertificates?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            clientCertificate?: pulumi.Input<string>;
            /**
             * The name of the secret that holds the TLS certs for the client including the CA certificates.
             */
            credentialName?: pulumi.Input<string>;
            /**
             * InsecureSkipVerify specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
             */
            insecureSkipVerify?: pulumi.Input<boolean>;
            /**
             * Indicates whether connections to this port should be secured using TLS.
             */
            mode?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            privateKey?: pulumi.Input<string>;
            /**
             * SNI string to present to the server during TLS handshake.
             */
            sni?: pulumi.Input<string>;
            /**
             * A list of alternate names to verify the subject identity in the certificate.
             */
            subjectAltNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
         */
        export interface DestinationRuleSpecTrafficPolicyTunnelArgs {
            /**
             * Specifies which protocol to use for tunneling the downstream connection.
             */
            protocol?: pulumi.Input<string>;
            /**
             * Specifies a host to which the downstream connection is tunneled.
             */
            targetHost: pulumi.Input<string>;
            /**
             * Specifies a port to which the downstream connection is tunneled.
             */
            targetPort: pulumi.Input<number>;
        }

        /**
         * Criteria used to select the specific set of pods/VMs on which this `DestinationRule` configuration should be applied.
         */
        export interface DestinationRuleSpecWorkloadSelectorArgs {
            /**
             * One or more labels that indicate a specific set of pods/VMs on which a policy should be applied.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Configuration affecting edge load balancer. See more details at: https://istio.io/docs/reference/config/networking/gateway.html
         */
        export interface GatewaySpecArgs {
            /**
             * One or more labels that indicate a specific set of pods/VMs on which this gateway configuration should be applied.
             */
            selector?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * A list of server specifications.
             */
            servers?: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.GatewaySpecServersArgs>[]>;
        }

        export interface GatewaySpecServersArgs {
            /**
             * The ip or the Unix domain socket to which the listener should be bound to.
             */
            bind?: pulumi.Input<string>;
            defaultEndpoint?: pulumi.Input<string>;
            /**
             * One or more hosts exposed by this gateway.
             */
            hosts: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * An optional name of the server, when set must be unique across all servers.
             */
            name?: pulumi.Input<string>;
            /**
             * The Port on which the proxy should listen for incoming connections.
             */
            port: pulumi.Input<inputs.networking.v1beta1.GatewaySpecServersPortArgs>;
            /**
             * Set of TLS related options that govern the server's behavior.
             */
            tls?: pulumi.Input<inputs.networking.v1beta1.GatewaySpecServersTlsArgs>;
        }

        /**
         * The Port on which the proxy should listen for incoming connections.
         */
        export interface GatewaySpecServersPortArgs {
            /**
             * Label assigned to the port.
             */
            name: pulumi.Input<string>;
            /**
             * A valid non-negative integer port number.
             */
            number: pulumi.Input<number>;
            /**
             * The protocol exposed on the port.
             */
            protocol: pulumi.Input<string>;
            targetPort?: pulumi.Input<number>;
        }

        /**
         * Set of TLS related options that govern the server's behavior.
         */
        export interface GatewaySpecServersTlsArgs {
            /**
             * REQUIRED if mode is `MUTUAL` or `OPTIONAL_MUTUAL`.
             */
            caCertificates?: pulumi.Input<string>;
            /**
             * Optional: If specified, only support the specified cipher list.
             */
            cipherSuites?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * For gateways running on Kubernetes, the name of the secret that holds the TLS certs including the CA certificates.
             */
            credentialName?: pulumi.Input<string>;
            /**
             * If set to true, the load balancer will send a 301 redirect for all http connections, asking the clients to use HTTPS.
             */
            httpsRedirect?: pulumi.Input<boolean>;
            /**
             * Optional: Maximum TLS protocol version.
             */
            maxProtocolVersion?: pulumi.Input<string>;
            /**
             * Optional: Minimum TLS protocol version.
             */
            minProtocolVersion?: pulumi.Input<string>;
            /**
             * Optional: Indicates whether connections to this port should be secured using TLS.
             */
            mode?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
             */
            privateKey?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
             */
            serverCertificate?: pulumi.Input<string>;
            /**
             * A list of alternate names to verify the subject identity in the certificate presented by the client.
             */
            subjectAltNames?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * An optional list of hex-encoded SHA-256 hashes of the authorized client certificates.
             */
            verifyCertificateHash?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * An optional list of base64-encoded SHA-256 hashes of the SPKIs of authorized client certificates.
             */
            verifyCertificateSpki?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Provides configuration for individual workloads. See more details at: https://istio.io/docs/reference/config/networking/proxy-config.html
         */
        export interface ProxyConfigSpecArgs {
            /**
             * The number of worker threads to run.
             */
            concurrency?: pulumi.Input<number>;
            /**
             * Additional environment variables for the proxy.
             */
            environmentVariables?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Specifies the details of the proxy image.
             */
            image?: pulumi.Input<inputs.networking.v1beta1.ProxyConfigSpecImageArgs>;
            /**
             * Optional.
             */
            selector?: pulumi.Input<inputs.networking.v1beta1.ProxyConfigSpecSelectorArgs>;
        }

        /**
         * Specifies the details of the proxy image.
         */
        export interface ProxyConfigSpecImageArgs {
            /**
             * The image type of the image.
             */
            imageType?: pulumi.Input<string>;
        }

        /**
         * Optional.
         */
        export interface ProxyConfigSpecSelectorArgs {
            /**
             * One or more labels that indicate a specific set of pods/VMs on which a policy should be applied.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Configuration affecting service registry. See more details at: https://istio.io/docs/reference/config/networking/service-entry.html
         */
        export interface ServiceEntrySpecArgs {
            /**
             * The virtual IP addresses associated with the service.
             */
            addresses?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * One or more endpoints associated with the service.
             */
            endpoints?: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.ServiceEntrySpecEndpointsArgs>[]>;
            /**
             * A list of namespaces to which this service is exported.
             */
            exportTo?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * The hosts associated with the ServiceEntry.
             */
            hosts: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Specify whether the service should be considered external to the mesh or part of the mesh.
             */
            location?: pulumi.Input<string>;
            /**
             * The ports associated with the external service.
             */
            ports?: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.ServiceEntrySpecPortsArgs>[]>;
            /**
             * Service resolution mode for the hosts.
             */
            resolution?: pulumi.Input<string>;
            /**
             * If specified, the proxy will verify that the server certificate's subject alternate name matches one of the specified values.
             */
            subjectAltNames?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Applicable only for MESH_INTERNAL services.
             */
            workloadSelector?: pulumi.Input<inputs.networking.v1beta1.ServiceEntrySpecWorkloadSelectorArgs>;
        }

        export interface ServiceEntrySpecEndpointsArgs {
            /**
             * Address associated with the network endpoint without the port.
             */
            address?: pulumi.Input<string>;
            /**
             * One or more labels associated with the endpoint.
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * The locality associated with the endpoint.
             */
            locality?: pulumi.Input<string>;
            /**
             * Network enables Istio to group endpoints resident in the same L3 domain/network.
             */
            network?: pulumi.Input<string>;
            /**
             * Set of ports associated with the endpoint.
             */
            ports?: pulumi.Input<{[key: string]: pulumi.Input<number>}>;
            /**
             * The service account associated with the workload if a sidecar is present in the workload.
             */
            serviceAccount?: pulumi.Input<string>;
            /**
             * The load balancing weight associated with the endpoint.
             */
            weight?: pulumi.Input<number>;
        }

        export interface ServiceEntrySpecPortsArgs {
            /**
             * Label assigned to the port.
             */
            name: pulumi.Input<string>;
            /**
             * A valid non-negative integer port number.
             */
            number: pulumi.Input<number>;
            /**
             * The protocol exposed on the port.
             */
            protocol?: pulumi.Input<string>;
            /**
             * The port number on the endpoint where the traffic will be received.
             */
            targetPort?: pulumi.Input<number>;
        }

        /**
         * Applicable only for MESH_INTERNAL services.
         */
        export interface ServiceEntrySpecWorkloadSelectorArgs {
            /**
             * One or more labels that indicate a specific set of pods/VMs on which the configuration should be applied.
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Configuration affecting network reachability of a sidecar. See more details at: https://istio.io/docs/reference/config/networking/sidecar.html
         */
        export interface SidecarSpecArgs {
            /**
             * Egress specifies the configuration of the sidecar for processing outbound traffic from the attached workload instance to other services in the mesh.
             */
            egress?: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.SidecarSpecEgressArgs>[]>;
            /**
             * Settings controlling the volume of connections Envoy will accept from the network.
             */
            inboundConnectionPool?: pulumi.Input<inputs.networking.v1beta1.SidecarSpecInboundConnectionPoolArgs>;
            /**
             * Ingress specifies the configuration of the sidecar for processing inbound traffic to the attached workload instance.
             */
            ingress?: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.SidecarSpecIngressArgs>[]>;
            /**
             * Configuration for the outbound traffic policy.
             */
            outboundTrafficPolicy?: pulumi.Input<inputs.networking.v1beta1.SidecarSpecOutboundTrafficPolicyArgs>;
            /**
             * Criteria used to select the specific set of pods/VMs on which this `Sidecar` configuration should be applied.
             */
            workloadSelector?: pulumi.Input<inputs.networking.v1beta1.SidecarSpecWorkloadSelectorArgs>;
        }

        export interface SidecarSpecEgressArgs {
            /**
             * The IP(IPv4 or IPv6) or the Unix domain socket to which the listener should be bound to.
             */
            bind?: pulumi.Input<string>;
            /**
             * When the bind address is an IP, the captureMode option dictates how traffic to the listener is expected to be captured (or not).
             */
            captureMode?: pulumi.Input<string>;
            /**
             * One or more service hosts exposed by the listener in `namespace/dnsName` format.
             */
            hosts: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * The port associated with the listener.
             */
            port?: pulumi.Input<inputs.networking.v1beta1.SidecarSpecEgressPortArgs>;
        }

        /**
         * The port associated with the listener.
         */
        export interface SidecarSpecEgressPortArgs {
            /**
             * Label assigned to the port.
             */
            name?: pulumi.Input<string>;
            /**
             * A valid non-negative integer port number.
             */
            number?: pulumi.Input<number>;
            /**
             * The protocol exposed on the port.
             */
            protocol?: pulumi.Input<string>;
            targetPort?: pulumi.Input<number>;
        }

        /**
         * Settings controlling the volume of connections Envoy will accept from the network.
         */
        export interface SidecarSpecInboundConnectionPoolArgs {
            /**
             * HTTP connection pool settings.
             */
            http?: pulumi.Input<inputs.networking.v1beta1.SidecarSpecInboundConnectionPoolHttpArgs>;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: pulumi.Input<inputs.networking.v1beta1.SidecarSpecInboundConnectionPoolTcpArgs>;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface SidecarSpecInboundConnectionPoolHttpArgs {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: pulumi.Input<string>;
            /**
             * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
             */
            http1MaxPendingRequests?: pulumi.Input<number>;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: pulumi.Input<number>;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: pulumi.Input<string>;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            /**
             * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
             */
            maxRetries?: pulumi.Input<number>;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: pulumi.Input<boolean>;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface SidecarSpecInboundConnectionPoolTcpArgs {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: pulumi.Input<inputs.networking.v1beta1.SidecarSpecInboundConnectionPoolTcpTcpKeepaliveArgs>;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface SidecarSpecInboundConnectionPoolTcpTcpKeepaliveArgs {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: pulumi.Input<string>;
            /**
             * Maximum number of keepalive probes to send without response before deciding the connection is dead.
             */
            probes?: pulumi.Input<number>;
            /**
             * The time duration a connection needs to be idle before keep-alive probes start being sent.
             */
            time?: pulumi.Input<string>;
        }

        export interface SidecarSpecIngressArgs {
            /**
             * The IP(IPv4 or IPv6) to which the listener should be bound.
             */
            bind?: pulumi.Input<string>;
            /**
             * The captureMode option dictates how traffic to the listener is expected to be captured (or not).
             */
            captureMode?: pulumi.Input<string>;
            /**
             * Settings controlling the volume of connections Envoy will accept from the network.
             */
            connectionPool?: pulumi.Input<inputs.networking.v1beta1.SidecarSpecIngressConnectionPoolArgs>;
            /**
             * The IP endpoint or Unix domain socket to which traffic should be forwarded to.
             */
            defaultEndpoint?: pulumi.Input<string>;
            /**
             * The port associated with the listener.
             */
            port: pulumi.Input<inputs.networking.v1beta1.SidecarSpecIngressPortArgs>;
            /**
             * Set of TLS related options that will enable TLS termination on the sidecar for requests originating from outside the mesh.
             */
            tls?: pulumi.Input<inputs.networking.v1beta1.SidecarSpecIngressTlsArgs>;
        }

        /**
         * Settings controlling the volume of connections Envoy will accept from the network.
         */
        export interface SidecarSpecIngressConnectionPoolArgs {
            /**
             * HTTP connection pool settings.
             */
            http?: pulumi.Input<inputs.networking.v1beta1.SidecarSpecIngressConnectionPoolHttpArgs>;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: pulumi.Input<inputs.networking.v1beta1.SidecarSpecIngressConnectionPoolTcpArgs>;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface SidecarSpecIngressConnectionPoolHttpArgs {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: pulumi.Input<string>;
            /**
             * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
             */
            http1MaxPendingRequests?: pulumi.Input<number>;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: pulumi.Input<number>;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: pulumi.Input<string>;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            /**
             * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
             */
            maxRetries?: pulumi.Input<number>;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: pulumi.Input<boolean>;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface SidecarSpecIngressConnectionPoolTcpArgs {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: pulumi.Input<inputs.networking.v1beta1.SidecarSpecIngressConnectionPoolTcpTcpKeepaliveArgs>;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface SidecarSpecIngressConnectionPoolTcpTcpKeepaliveArgs {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: pulumi.Input<string>;
            /**
             * Maximum number of keepalive probes to send without response before deciding the connection is dead.
             */
            probes?: pulumi.Input<number>;
            /**
             * The time duration a connection needs to be idle before keep-alive probes start being sent.
             */
            time?: pulumi.Input<string>;
        }

        /**
         * The port associated with the listener.
         */
        export interface SidecarSpecIngressPortArgs {
            /**
             * Label assigned to the port.
             */
            name?: pulumi.Input<string>;
            /**
             * A valid non-negative integer port number.
             */
            number?: pulumi.Input<number>;
            /**
             * The protocol exposed on the port.
             */
            protocol?: pulumi.Input<string>;
            targetPort?: pulumi.Input<number>;
        }

        /**
         * Set of TLS related options that will enable TLS termination on the sidecar for requests originating from outside the mesh.
         */
        export interface SidecarSpecIngressTlsArgs {
            /**
             * REQUIRED if mode is `MUTUAL` or `OPTIONAL_MUTUAL`.
             */
            caCertificates?: pulumi.Input<string>;
            /**
             * Optional: If specified, only support the specified cipher list.
             */
            cipherSuites?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * For gateways running on Kubernetes, the name of the secret that holds the TLS certs including the CA certificates.
             */
            credentialName?: pulumi.Input<string>;
            /**
             * If set to true, the load balancer will send a 301 redirect for all http connections, asking the clients to use HTTPS.
             */
            httpsRedirect?: pulumi.Input<boolean>;
            /**
             * Optional: Maximum TLS protocol version.
             */
            maxProtocolVersion?: pulumi.Input<string>;
            /**
             * Optional: Minimum TLS protocol version.
             */
            minProtocolVersion?: pulumi.Input<string>;
            /**
             * Optional: Indicates whether connections to this port should be secured using TLS.
             */
            mode?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
             */
            privateKey?: pulumi.Input<string>;
            /**
             * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
             */
            serverCertificate?: pulumi.Input<string>;
            /**
             * A list of alternate names to verify the subject identity in the certificate presented by the client.
             */
            subjectAltNames?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * An optional list of hex-encoded SHA-256 hashes of the authorized client certificates.
             */
            verifyCertificateHash?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * An optional list of base64-encoded SHA-256 hashes of the SPKIs of authorized client certificates.
             */
            verifyCertificateSpki?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Configuration for the outbound traffic policy.
         */
        export interface SidecarSpecOutboundTrafficPolicyArgs {
            egressProxy?: pulumi.Input<inputs.networking.v1beta1.SidecarSpecOutboundTrafficPolicyEgressProxyArgs>;
            mode?: pulumi.Input<string>;
        }

        export interface SidecarSpecOutboundTrafficPolicyEgressProxyArgs {
            /**
             * The name of a service from the service registry.
             */
            host: pulumi.Input<string>;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: pulumi.Input<inputs.networking.v1beta1.SidecarSpecOutboundTrafficPolicyEgressProxyPortArgs>;
            /**
             * The name of a subset within the service.
             */
            subset?: pulumi.Input<string>;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface SidecarSpecOutboundTrafficPolicyEgressProxyPortArgs {
            number?: pulumi.Input<number>;
        }

        /**
         * Criteria used to select the specific set of pods/VMs on which this `Sidecar` configuration should be applied.
         */
        export interface SidecarSpecWorkloadSelectorArgs {
            /**
             * One or more labels that indicate a specific set of pods/VMs on which the configuration should be applied.
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Configuration affecting label/content routing, sni routing, etc. See more details at: https://istio.io/docs/reference/config/networking/virtual-service.html
         */
        export interface VirtualServiceSpecArgs {
            /**
             * A list of namespaces to which this virtual service is exported.
             */
            exportTo?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * The names of gateways and sidecars that should apply these routes.
             */
            gateways?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * The destination hosts to which traffic is being sent.
             */
            hosts?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * An ordered list of route rules for HTTP traffic.
             */
            http?: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpArgs>[]>;
            /**
             * An ordered list of route rules for opaque TCP traffic.
             */
            tcp?: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecTcpArgs>[]>;
            /**
             * An ordered list of route rule for non-terminated TLS & HTTPS traffic.
             */
            tls?: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecTlsArgs>[]>;
        }

        export interface VirtualServiceSpecHttpArgs {
            /**
             * Cross-Origin Resource Sharing policy (CORS).
             */
            corsPolicy?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpCorsPolicyArgs>;
            /**
             * Delegate is used to specify the particular VirtualService which can be used to define delegate HTTPRoute.
             */
            delegate?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpDelegateArgs>;
            /**
             * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
             */
            directResponse?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpDirectResponseArgs>;
            /**
             * Fault injection policy to apply on HTTP traffic at the client side.
             */
            fault?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpFaultArgs>;
            headers?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpHeadersArgs>;
            /**
             * Match conditions to be satisfied for the rule to be activated.
             */
            match?: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpMatchArgs>[]>;
            /**
             * Mirror HTTP traffic to a another destination in addition to forwarding the requests to the intended destination.
             */
            mirror?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpMirrorArgs>;
            mirrorPercent?: pulumi.Input<number>;
            /**
             * Percentage of the traffic to be mirrored by the `mirror` field.
             */
            mirrorPercentage?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpMirrorPercentageArgs>;
            mirror_percent?: pulumi.Input<number>;
            /**
             * Specifies the destinations to mirror HTTP traffic in addition to the original destination.
             */
            mirrors?: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpMirrorsArgs>[]>;
            /**
             * The name assigned to the route for debugging purposes.
             */
            name?: pulumi.Input<string>;
            /**
             * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
             */
            redirect?: any;
            /**
             * Retry policy for HTTP requests.
             */
            retries?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpRetriesArgs>;
            /**
             * Rewrite HTTP URIs and Authority headers.
             */
            rewrite?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpRewriteArgs>;
            /**
             * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
             */
            route?: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpRouteArgs>[]>;
            /**
             * Timeout for HTTP requests, default is disabled.
             */
            timeout?: pulumi.Input<string>;
        }

        /**
         * Cross-Origin Resource Sharing policy (CORS).
         */
        export interface VirtualServiceSpecHttpCorsPolicyArgs {
            /**
             * Indicates whether the caller is allowed to send the actual request (not the preflight) using credentials.
             */
            allowCredentials?: pulumi.Input<boolean>;
            /**
             * List of HTTP headers that can be used when requesting the resource.
             */
            allowHeaders?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * List of HTTP methods allowed to access the resource.
             */
            allowMethods?: pulumi.Input<pulumi.Input<string>[]>;
            allowOrigin?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * String patterns that match allowed origins.
             */
            allowOrigins?: pulumi.Input<any[]>;
            /**
             * A list of HTTP headers that the browsers are allowed to access.
             */
            exposeHeaders?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Specifies how long the results of a preflight request can be cached.
             */
            maxAge?: pulumi.Input<string>;
        }

        /**
         * Delegate is used to specify the particular VirtualService which can be used to define delegate HTTPRoute.
         */
        export interface VirtualServiceSpecHttpDelegateArgs {
            /**
             * Name specifies the name of the delegate VirtualService.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace specifies the namespace where the delegate VirtualService resides.
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
         */
        export interface VirtualServiceSpecHttpDirectResponseArgs {
            /**
             * Specifies the content of the response body.
             */
            body?: any;
            /**
             * Specifies the HTTP response status to be returned.
             */
            status: pulumi.Input<number>;
        }

        /**
         * Fault injection policy to apply on HTTP traffic at the client side.
         */
        export interface VirtualServiceSpecHttpFaultArgs {
            /**
             * Abort Http request attempts and return error codes back to downstream service, giving the impression that the upstream service is faulty.
             */
            abort?: any;
            /**
             * Delay requests before forwarding, emulating various failures such as network issues, overloaded upstream service, etc.
             */
            delay?: any;
        }

        export interface VirtualServiceSpecHttpHeadersArgs {
            request?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpHeadersRequestArgs>;
            response?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpHeadersResponseArgs>;
        }

        export interface VirtualServiceSpecHttpHeadersRequestArgs {
            add?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            remove?: pulumi.Input<pulumi.Input<string>[]>;
            set?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface VirtualServiceSpecHttpHeadersResponseArgs {
            add?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            remove?: pulumi.Input<pulumi.Input<string>[]>;
            set?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface VirtualServiceSpecHttpMatchArgs {
            /**
             * HTTP Authority values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
             */
            authority?: any;
            /**
             * Names of gateways where the rule should be applied.
             */
            gateways?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * The header keys must be lowercase and use hyphen as the separator, e.g.
             */
            headers?: pulumi.Input<{[key: string]: any}>;
            /**
             * Flag to specify whether the URI matching should be case-insensitive.
             */
            ignoreUriCase?: pulumi.Input<boolean>;
            /**
             * HTTP Method values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
             */
            method?: any;
            /**
             * The name assigned to a match.
             */
            name?: pulumi.Input<string>;
            /**
             * Specifies the ports on the host that is being addressed.
             */
            port?: pulumi.Input<number>;
            /**
             * Query parameters for matching.
             */
            queryParams?: pulumi.Input<{[key: string]: any}>;
            /**
             * URI Scheme values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
             */
            scheme?: any;
            /**
             * One or more labels that constrain the applicability of a rule to source (client) workloads with the given labels.
             */
            sourceLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Source namespace constraining the applicability of a rule to workloads in that namespace.
             */
            sourceNamespace?: pulumi.Input<string>;
            /**
             * The human readable prefix to use when emitting statistics for this route.
             */
            statPrefix?: pulumi.Input<string>;
            /**
             * URI to match values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
             */
            uri?: any;
            /**
             * withoutHeader has the same syntax with the header, but has opposite meaning.
             */
            withoutHeaders?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Mirror HTTP traffic to a another destination in addition to forwarding the requests to the intended destination.
         */
        export interface VirtualServiceSpecHttpMirrorArgs {
            /**
             * The name of a service from the service registry.
             */
            host: pulumi.Input<string>;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpMirrorPortArgs>;
            /**
             * The name of a subset within the service.
             */
            subset?: pulumi.Input<string>;
        }

        /**
         * Percentage of the traffic to be mirrored by the `mirror` field.
         */
        export interface VirtualServiceSpecHttpMirrorPercentageArgs {
            value?: pulumi.Input<number>;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecHttpMirrorPortArgs {
            number?: pulumi.Input<number>;
        }

        export interface VirtualServiceSpecHttpMirrorsArgs {
            /**
             * Destination specifies the target of the mirror operation.
             */
            destination: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpMirrorsDestinationArgs>;
            /**
             * Percentage of the traffic to be mirrored by the `destination` field.
             */
            percentage?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpMirrorsPercentageArgs>;
        }

        /**
         * Destination specifies the target of the mirror operation.
         */
        export interface VirtualServiceSpecHttpMirrorsDestinationArgs {
            /**
             * The name of a service from the service registry.
             */
            host: pulumi.Input<string>;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpMirrorsDestinationPortArgs>;
            /**
             * The name of a subset within the service.
             */
            subset?: pulumi.Input<string>;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecHttpMirrorsDestinationPortArgs {
            number?: pulumi.Input<number>;
        }

        /**
         * Percentage of the traffic to be mirrored by the `destination` field.
         */
        export interface VirtualServiceSpecHttpMirrorsPercentageArgs {
            value?: pulumi.Input<number>;
        }

        /**
         * Retry policy for HTTP requests.
         */
        export interface VirtualServiceSpecHttpRetriesArgs {
            /**
             * Number of retries to be allowed for a given request.
             */
            attempts?: pulumi.Input<number>;
            /**
             * Timeout per attempt for a given request, including the initial call and any retries.
             */
            perTryTimeout?: pulumi.Input<string>;
            /**
             * Specifies the conditions under which retry takes place.
             */
            retryOn?: pulumi.Input<string>;
            /**
             * Flag to specify whether the retries should retry to other localities.
             */
            retryRemoteLocalities?: pulumi.Input<boolean>;
        }

        /**
         * Rewrite HTTP URIs and Authority headers.
         */
        export interface VirtualServiceSpecHttpRewriteArgs {
            /**
             * rewrite the Authority/Host header with this value.
             */
            authority?: pulumi.Input<string>;
            /**
             * rewrite the path (or the prefix) portion of the URI with this value.
             */
            uri?: pulumi.Input<string>;
            /**
             * rewrite the path portion of the URI with the specified regex.
             */
            uriRegexRewrite?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpRewriteUriRegexRewriteArgs>;
        }

        /**
         * rewrite the path portion of the URI with the specified regex.
         */
        export interface VirtualServiceSpecHttpRewriteUriRegexRewriteArgs {
            /**
             * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
             */
            match?: pulumi.Input<string>;
            /**
             * The string that should replace into matching portions of original URI.
             */
            rewrite?: pulumi.Input<string>;
        }

        export interface VirtualServiceSpecHttpRouteArgs {
            /**
             * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
             */
            destination: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpRouteDestinationArgs>;
            headers?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpRouteHeadersArgs>;
            /**
             * Weight specifies the relative proportion of traffic to be forwarded to the destination.
             */
            weight?: pulumi.Input<number>;
        }

        /**
         * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
         */
        export interface VirtualServiceSpecHttpRouteDestinationArgs {
            /**
             * The name of a service from the service registry.
             */
            host: pulumi.Input<string>;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpRouteDestinationPortArgs>;
            /**
             * The name of a subset within the service.
             */
            subset?: pulumi.Input<string>;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecHttpRouteDestinationPortArgs {
            number?: pulumi.Input<number>;
        }

        export interface VirtualServiceSpecHttpRouteHeadersArgs {
            request?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpRouteHeadersRequestArgs>;
            response?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecHttpRouteHeadersResponseArgs>;
        }

        export interface VirtualServiceSpecHttpRouteHeadersRequestArgs {
            add?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            remove?: pulumi.Input<pulumi.Input<string>[]>;
            set?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface VirtualServiceSpecHttpRouteHeadersResponseArgs {
            add?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            remove?: pulumi.Input<pulumi.Input<string>[]>;
            set?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface VirtualServiceSpecTcpArgs {
            /**
             * Match conditions to be satisfied for the rule to be activated.
             */
            match?: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecTcpMatchArgs>[]>;
            /**
             * The destination to which the connection should be forwarded to.
             */
            route?: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecTcpRouteArgs>[]>;
        }

        export interface VirtualServiceSpecTcpMatchArgs {
            /**
             * IPv4 or IPv6 ip addresses of destination with optional subnet.
             */
            destinationSubnets?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Names of gateways where the rule should be applied.
             */
            gateways?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: pulumi.Input<number>;
            /**
             * One or more labels that constrain the applicability of a rule to workloads with the given labels.
             */
            sourceLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Source namespace constraining the applicability of a rule to workloads in that namespace.
             */
            sourceNamespace?: pulumi.Input<string>;
            sourceSubnet?: pulumi.Input<string>;
        }

        export interface VirtualServiceSpecTcpRouteArgs {
            /**
             * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
             */
            destination: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecTcpRouteDestinationArgs>;
            /**
             * Weight specifies the relative proportion of traffic to be forwarded to the destination.
             */
            weight?: pulumi.Input<number>;
        }

        /**
         * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
         */
        export interface VirtualServiceSpecTcpRouteDestinationArgs {
            /**
             * The name of a service from the service registry.
             */
            host: pulumi.Input<string>;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecTcpRouteDestinationPortArgs>;
            /**
             * The name of a subset within the service.
             */
            subset?: pulumi.Input<string>;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecTcpRouteDestinationPortArgs {
            number?: pulumi.Input<number>;
        }

        export interface VirtualServiceSpecTlsArgs {
            /**
             * Match conditions to be satisfied for the rule to be activated.
             */
            match: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecTlsMatchArgs>[]>;
            /**
             * The destination to which the connection should be forwarded to.
             */
            route?: pulumi.Input<pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecTlsRouteArgs>[]>;
        }

        export interface VirtualServiceSpecTlsMatchArgs {
            /**
             * IPv4 or IPv6 ip addresses of destination with optional subnet.
             */
            destinationSubnets?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Names of gateways where the rule should be applied.
             */
            gateways?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: pulumi.Input<number>;
            /**
             * SNI (server name indicator) to match on.
             */
            sniHosts: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * One or more labels that constrain the applicability of a rule to workloads with the given labels.
             */
            sourceLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Source namespace constraining the applicability of a rule to workloads in that namespace.
             */
            sourceNamespace?: pulumi.Input<string>;
        }

        export interface VirtualServiceSpecTlsRouteArgs {
            /**
             * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
             */
            destination: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecTlsRouteDestinationArgs>;
            /**
             * Weight specifies the relative proportion of traffic to be forwarded to the destination.
             */
            weight?: pulumi.Input<number>;
        }

        /**
         * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
         */
        export interface VirtualServiceSpecTlsRouteDestinationArgs {
            /**
             * The name of a service from the service registry.
             */
            host: pulumi.Input<string>;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: pulumi.Input<inputs.networking.v1beta1.VirtualServiceSpecTlsRouteDestinationPortArgs>;
            /**
             * The name of a subset within the service.
             */
            subset?: pulumi.Input<string>;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecTlsRouteDestinationPortArgs {
            number?: pulumi.Input<number>;
        }

        /**
         * Configuration affecting VMs onboarded into the mesh. See more details at: https://istio.io/docs/reference/config/networking/workload-entry.html
         */
        export interface WorkloadEntrySpecArgs {
            /**
             * Address associated with the network endpoint without the port.
             */
            address?: pulumi.Input<string>;
            /**
             * One or more labels associated with the endpoint.
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * The locality associated with the endpoint.
             */
            locality?: pulumi.Input<string>;
            /**
             * Network enables Istio to group endpoints resident in the same L3 domain/network.
             */
            network?: pulumi.Input<string>;
            /**
             * Set of ports associated with the endpoint.
             */
            ports?: pulumi.Input<{[key: string]: pulumi.Input<number>}>;
            /**
             * The service account associated with the workload if a sidecar is present in the workload.
             */
            serviceAccount?: pulumi.Input<string>;
            /**
             * The load balancing weight associated with the endpoint.
             */
            weight?: pulumi.Input<number>;
        }

        /**
         * `WorkloadGroup` enables specifying the properties of a single workload for bootstrap and provides a template for `WorkloadEntry`, similar to how `Deployment` specifies properties of workloads via `Pod` templates.
         */
        export interface WorkloadGroupSpecArgs {
            /**
             * Metadata that will be used for all corresponding `WorkloadEntries`.
             */
            metadata?: pulumi.Input<inputs.networking.v1beta1.WorkloadGroupSpecMetadataArgs>;
            /**
             * `ReadinessProbe` describes the configuration the user must provide for healthchecking on their workload.
             */
            probe?: any;
            /**
             * Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
             */
            template: pulumi.Input<inputs.networking.v1beta1.WorkloadGroupSpecTemplateArgs>;
        }

        /**
         * Metadata that will be used for all corresponding `WorkloadEntries`.
         */
        export interface WorkloadGroupSpecMetadataArgs {
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
         */
        export interface WorkloadGroupSpecTemplateArgs {
            /**
             * Address associated with the network endpoint without the port.
             */
            address?: pulumi.Input<string>;
            /**
             * One or more labels associated with the endpoint.
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * The locality associated with the endpoint.
             */
            locality?: pulumi.Input<string>;
            /**
             * Network enables Istio to group endpoints resident in the same L3 domain/network.
             */
            network?: pulumi.Input<string>;
            /**
             * Set of ports associated with the endpoint.
             */
            ports?: pulumi.Input<{[key: string]: pulumi.Input<number>}>;
            /**
             * The service account associated with the workload if a sidecar is present in the workload.
             */
            serviceAccount?: pulumi.Input<string>;
            /**
             * The load balancing weight associated with the endpoint.
             */
            weight?: pulumi.Input<number>;
        }

    }
}

export namespace security {
    export namespace v1 {
        /**
         * Request authentication configuration for workloads. See more details at: https://istio.io/docs/reference/config/security/request_authentication.html
         */
        export interface RequestAuthenticationSpecArgs {
            /**
             * Define the list of JWTs that can be validated at the selected workloads' proxy.
             */
            jwtRules?: pulumi.Input<pulumi.Input<inputs.security.v1.RequestAuthenticationSpecJwtRulesArgs>[]>;
            /**
             * Optional.
             */
            selector?: pulumi.Input<inputs.security.v1.RequestAuthenticationSpecSelectorArgs>;
            targetRef?: pulumi.Input<inputs.security.v1.RequestAuthenticationSpecTargetRefArgs>;
        }

        export interface RequestAuthenticationSpecJwtRulesArgs {
            /**
             * The list of JWT [audiences](https://tools.ietf.org/html/rfc7519#section-4.1.3) that are allowed to access.
             */
            audiences?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * If set to true, the original token will be kept for the upstream request.
             */
            forwardOriginalToken?: pulumi.Input<boolean>;
            /**
             * List of header locations from which JWT is expected.
             */
            fromHeaders?: pulumi.Input<pulumi.Input<inputs.security.v1.RequestAuthenticationSpecJwtRulesFromHeadersArgs>[]>;
            /**
             * List of query parameters from which JWT is expected.
             */
            fromParams?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Identifies the issuer that issued the JWT.
             */
            issuer: pulumi.Input<string>;
            /**
             * JSON Web Key Set of public keys to validate signature of the JWT.
             */
            jwks?: pulumi.Input<string>;
            /**
             * URL of the provider's public key set to validate signature of the JWT.
             */
            jwksUri?: pulumi.Input<string>;
            /**
             * URL of the provider's public key set to validate signature of the JWT.
             */
            jwks_uri?: pulumi.Input<string>;
            /**
             * This field specifies a list of operations to copy the claim to HTTP headers on a successfully verified token.
             */
            outputClaimToHeaders?: pulumi.Input<pulumi.Input<inputs.security.v1.RequestAuthenticationSpecJwtRulesOutputClaimToHeadersArgs>[]>;
            /**
             * This field specifies the header name to output a successfully verified JWT payload to the backend.
             */
            outputPayloadToHeader?: pulumi.Input<string>;
        }

        export interface RequestAuthenticationSpecJwtRulesFromHeadersArgs {
            /**
             * The HTTP header name.
             */
            name: pulumi.Input<string>;
            /**
             * The prefix that should be stripped before decoding the token.
             */
            prefix?: pulumi.Input<string>;
        }

        export interface RequestAuthenticationSpecJwtRulesOutputClaimToHeadersArgs {
            /**
             * The name of the claim to be copied from.
             */
            claim?: pulumi.Input<string>;
            /**
             * The name of the header to be created.
             */
            header?: pulumi.Input<string>;
        }

        /**
         * Optional.
         */
        export interface RequestAuthenticationSpecSelectorArgs {
            /**
             * One or more labels that indicate a specific set of pods/VMs on which a policy should be applied.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface RequestAuthenticationSpecTargetRefArgs {
            group?: pulumi.Input<string>;
            kind?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            namespace?: pulumi.Input<string>;
        }
    }

    export namespace v1beta1 {
        /**
         * Peer authentication configuration for workloads. See more details at: https://istio.io/docs/reference/config/security/peer_authentication.html
         */
        export interface PeerAuthenticationSpecArgs {
            /**
             * Mutual TLS settings for workload.
             */
            mtls?: pulumi.Input<inputs.security.v1beta1.PeerAuthenticationSpecMtlsArgs>;
            /**
             * Port specific mutual TLS settings.
             */
            portLevelMtls?: pulumi.Input<{[key: string]: pulumi.Input<inputs.security.v1beta1.PeerAuthenticationSpecPortLevelMtlsArgs>}>;
            /**
             * The selector determines the workloads to apply the ChannelAuthentication on.
             */
            selector?: pulumi.Input<inputs.security.v1beta1.PeerAuthenticationSpecSelectorArgs>;
        }

        /**
         * Mutual TLS settings for workload.
         */
        export interface PeerAuthenticationSpecMtlsArgs {
            /**
             * Defines the mTLS mode used for peer authentication.
             */
            mode?: pulumi.Input<string>;
        }

        export interface PeerAuthenticationSpecPortLevelMtlsArgs {
            /**
             * Defines the mTLS mode used for peer authentication.
             */
            mode?: pulumi.Input<string>;
        }

        /**
         * The selector determines the workloads to apply the ChannelAuthentication on.
         */
        export interface PeerAuthenticationSpecSelectorArgs {
            /**
             * One or more labels that indicate a specific set of pods/VMs on which a policy should be applied.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Request authentication configuration for workloads. See more details at: https://istio.io/docs/reference/config/security/request_authentication.html
         */
        export interface RequestAuthenticationSpecArgs {
            /**
             * Define the list of JWTs that can be validated at the selected workloads' proxy.
             */
            jwtRules?: pulumi.Input<pulumi.Input<inputs.security.v1beta1.RequestAuthenticationSpecJwtRulesArgs>[]>;
            /**
             * Optional.
             */
            selector?: pulumi.Input<inputs.security.v1beta1.RequestAuthenticationSpecSelectorArgs>;
            targetRef?: pulumi.Input<inputs.security.v1beta1.RequestAuthenticationSpecTargetRefArgs>;
        }

        export interface RequestAuthenticationSpecJwtRulesArgs {
            /**
             * The list of JWT [audiences](https://tools.ietf.org/html/rfc7519#section-4.1.3) that are allowed to access.
             */
            audiences?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * If set to true, the original token will be kept for the upstream request.
             */
            forwardOriginalToken?: pulumi.Input<boolean>;
            /**
             * List of header locations from which JWT is expected.
             */
            fromHeaders?: pulumi.Input<pulumi.Input<inputs.security.v1beta1.RequestAuthenticationSpecJwtRulesFromHeadersArgs>[]>;
            /**
             * List of query parameters from which JWT is expected.
             */
            fromParams?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Identifies the issuer that issued the JWT.
             */
            issuer: pulumi.Input<string>;
            /**
             * JSON Web Key Set of public keys to validate signature of the JWT.
             */
            jwks?: pulumi.Input<string>;
            /**
             * URL of the provider's public key set to validate signature of the JWT.
             */
            jwksUri?: pulumi.Input<string>;
            /**
             * URL of the provider's public key set to validate signature of the JWT.
             */
            jwks_uri?: pulumi.Input<string>;
            /**
             * This field specifies a list of operations to copy the claim to HTTP headers on a successfully verified token.
             */
            outputClaimToHeaders?: pulumi.Input<pulumi.Input<inputs.security.v1beta1.RequestAuthenticationSpecJwtRulesOutputClaimToHeadersArgs>[]>;
            /**
             * This field specifies the header name to output a successfully verified JWT payload to the backend.
             */
            outputPayloadToHeader?: pulumi.Input<string>;
        }

        export interface RequestAuthenticationSpecJwtRulesFromHeadersArgs {
            /**
             * The HTTP header name.
             */
            name: pulumi.Input<string>;
            /**
             * The prefix that should be stripped before decoding the token.
             */
            prefix?: pulumi.Input<string>;
        }

        export interface RequestAuthenticationSpecJwtRulesOutputClaimToHeadersArgs {
            /**
             * The name of the claim to be copied from.
             */
            claim?: pulumi.Input<string>;
            /**
             * The name of the header to be created.
             */
            header?: pulumi.Input<string>;
        }

        /**
         * Optional.
         */
        export interface RequestAuthenticationSpecSelectorArgs {
            /**
             * One or more labels that indicate a specific set of pods/VMs on which a policy should be applied.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface RequestAuthenticationSpecTargetRefArgs {
            group?: pulumi.Input<string>;
            kind?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            namespace?: pulumi.Input<string>;
        }
    }
}

export namespace telemetry {
    export namespace v1alpha1 {
        /**
         * Telemetry configuration for workloads. See more details at: https://istio.io/docs/reference/config/telemetry.html
         */
        export interface TelemetrySpecArgs {
            /**
             * Optional.
             */
            accessLogging?: pulumi.Input<pulumi.Input<inputs.telemetry.v1alpha1.TelemetrySpecAccessLoggingArgs>[]>;
            /**
             * Optional.
             */
            metrics?: pulumi.Input<pulumi.Input<inputs.telemetry.v1alpha1.TelemetrySpecMetricsArgs>[]>;
            /**
             * Optional.
             */
            selector?: pulumi.Input<inputs.telemetry.v1alpha1.TelemetrySpecSelectorArgs>;
            targetRef?: pulumi.Input<inputs.telemetry.v1alpha1.TelemetrySpecTargetRefArgs>;
            /**
             * Optional.
             */
            tracing?: pulumi.Input<pulumi.Input<inputs.telemetry.v1alpha1.TelemetrySpecTracingArgs>[]>;
        }

        export interface TelemetrySpecAccessLoggingArgs {
            /**
             * Controls logging.
             */
            disabled?: pulumi.Input<boolean>;
            /**
             * Optional.
             */
            filter?: pulumi.Input<inputs.telemetry.v1alpha1.TelemetrySpecAccessLoggingFilterArgs>;
            /**
             * Allows tailoring of logging behavior to specific conditions.
             */
            match?: pulumi.Input<inputs.telemetry.v1alpha1.TelemetrySpecAccessLoggingMatchArgs>;
            /**
             * Optional.
             */
            providers?: pulumi.Input<pulumi.Input<inputs.telemetry.v1alpha1.TelemetrySpecAccessLoggingProvidersArgs>[]>;
        }

        /**
         * Optional.
         */
        export interface TelemetrySpecAccessLoggingFilterArgs {
            /**
             * CEL expression for selecting when requests/connections should be logged.
             */
            expression?: pulumi.Input<string>;
        }

        /**
         * Allows tailoring of logging behavior to specific conditions.
         */
        export interface TelemetrySpecAccessLoggingMatchArgs {
            /**
             * This determines whether or not to apply the access logging configuration based on the direction of traffic relative to the proxied workload.
             */
            mode?: pulumi.Input<string>;
        }

        export interface TelemetrySpecAccessLoggingProvidersArgs {
            /**
             * Required.
             */
            name: pulumi.Input<string>;
        }

        export interface TelemetrySpecMetricsArgs {
            /**
             * Optional.
             */
            overrides?: pulumi.Input<pulumi.Input<inputs.telemetry.v1alpha1.TelemetrySpecMetricsOverridesArgs>[]>;
            /**
             * Optional.
             */
            providers?: pulumi.Input<pulumi.Input<inputs.telemetry.v1alpha1.TelemetrySpecMetricsProvidersArgs>[]>;
            /**
             * Optional.
             */
            reportingInterval?: pulumi.Input<string>;
        }

        export interface TelemetrySpecMetricsOverridesArgs {
            /**
             * Optional.
             */
            disabled?: pulumi.Input<boolean>;
            /**
             * Match allows provides the scope of the override.
             */
            match?: any;
            /**
             * Optional.
             */
            tagOverrides?: pulumi.Input<{[key: string]: pulumi.Input<inputs.telemetry.v1alpha1.TelemetrySpecMetricsOverridesTagOverridesArgs>}>;
        }

        export interface TelemetrySpecMetricsOverridesTagOverridesArgs {
            /**
             * Operation controls whether or not to update/add a tag, or to remove it.
             */
            operation?: pulumi.Input<string>;
            /**
             * Value is only considered if the operation is `UPSERT`.
             */
            value?: pulumi.Input<string>;
        }

        export interface TelemetrySpecMetricsProvidersArgs {
            /**
             * Required.
             */
            name: pulumi.Input<string>;
        }

        /**
         * Optional.
         */
        export interface TelemetrySpecSelectorArgs {
            /**
             * One or more labels that indicate a specific set of pods/VMs on which a policy should be applied.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface TelemetrySpecTargetRefArgs {
            group?: pulumi.Input<string>;
            kind?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            namespace?: pulumi.Input<string>;
        }

        export interface TelemetrySpecTracingArgs {
            /**
             * Optional.
             */
            customTags?: pulumi.Input<{[key: string]: any}>;
            /**
             * Controls span reporting.
             */
            disableSpanReporting?: pulumi.Input<boolean>;
            /**
             * Allows tailoring of behavior to specific conditions.
             */
            match?: pulumi.Input<inputs.telemetry.v1alpha1.TelemetrySpecTracingMatchArgs>;
            /**
             * Optional.
             */
            providers?: pulumi.Input<pulumi.Input<inputs.telemetry.v1alpha1.TelemetrySpecTracingProvidersArgs>[]>;
            /**
             * Controls the rate at which traffic will be selected for tracing if no prior sampling decision has been made.
             */
            randomSamplingPercentage?: pulumi.Input<number>;
            useRequestIdForTraceSampling?: pulumi.Input<boolean>;
        }

        /**
         * Allows tailoring of behavior to specific conditions.
         */
        export interface TelemetrySpecTracingMatchArgs {
            /**
             * This determines whether or not to apply the tracing configuration based on the direction of traffic relative to the proxied workload.
             */
            mode?: pulumi.Input<string>;
        }

        export interface TelemetrySpecTracingProvidersArgs {
            /**
             * Required.
             */
            name: pulumi.Input<string>;
        }
    }
}
