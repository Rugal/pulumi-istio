// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

import {ObjectMeta} from "../meta/v1";

export namespace extensions {
    export namespace v1alpha1 {
        /**
         * Extend the functionality provided by the Istio proxy through WebAssembly filters. See more details at: https://istio.io/docs/reference/config/proxy_extensions/wasm-plugin.html
         */
        export interface WasmPluginSpec {
            /**
             * Specifies the failure behavior for the plugin due to fatal errors.
             */
            failStrategy?: string;
            /**
             * The pull behaviour to be applied when fetching Wasm module by either OCI image or http/https.
             */
            imagePullPolicy?: string;
            /**
             * Credentials to use for OCI image pulling.
             */
            imagePullSecret?: string;
            /**
             * Specifies the criteria to determine which traffic is passed to WasmPlugin.
             */
            match?: outputs.extensions.v1alpha1.WasmPluginSpecMatch[];
            /**
             * Determines where in the filter chain this `WasmPlugin` is to be injected.
             */
            phase?: string;
            /**
             * The configuration that will be passed on to the plugin.
             */
            pluginConfig?: {[key: string]: any};
            /**
             * The plugin name to be used in the Envoy configuration (used to be called `rootID`).
             */
            pluginName?: string;
            /**
             * Determines ordering of `WasmPlugins` in the same `phase`.
             */
            priority?: number;
            /**
             * Criteria used to select the specific set of pods/VMs on which this plugin configuration should be applied.
             */
            selector?: outputs.extensions.v1alpha1.WasmPluginSpecSelector;
            /**
             * SHA256 checksum that will be used to verify Wasm module or OCI container.
             */
            sha256?: string;
            targetRef?: outputs.extensions.v1alpha1.WasmPluginSpecTargetRef;
            /**
             * Specifies the type of Wasm Extension to be used.
             */
            type?: string;
            /**
             * URL of a Wasm module or OCI container.
             */
            url: string;
            verificationKey?: string;
            /**
             * Configuration for a Wasm VM.
             */
            vmConfig?: outputs.extensions.v1alpha1.WasmPluginSpecVmConfig;
        }

        export interface WasmPluginSpecMatch {
            /**
             * Criteria for selecting traffic by their direction.
             */
            mode?: string;
            /**
             * Criteria for selecting traffic by their destination port.
             */
            ports?: outputs.extensions.v1alpha1.WasmPluginSpecMatchPorts[];
        }

        export interface WasmPluginSpecMatchPorts {
            number: number;
        }

        /**
         * Criteria used to select the specific set of pods/VMs on which this plugin configuration should be applied.
         */
        export interface WasmPluginSpecSelector {
            /**
             * One or more labels that indicate a specific set of pods/VMs on which a policy should be applied.
             */
            matchLabels?: {[key: string]: string};
        }

        export interface WasmPluginSpecTargetRef {
            group?: string;
            kind?: string;
            name?: string;
            namespace?: string;
        }

        /**
         * Configuration for a Wasm VM.
         */
        export interface WasmPluginSpecVmConfig {
            /**
             * Specifies environment variables to be injected to this VM.
             */
            env?: outputs.extensions.v1alpha1.WasmPluginSpecVmConfigEnv[];
        }

        export interface WasmPluginSpecVmConfigEnv {
            /**
             * Name of the environment variable.
             */
            name: string;
            /**
             * Value for the environment variable.
             */
            value?: string;
            /**
             * Source for the environment variable's value.
             */
            valueFrom?: string;
        }

    }
}

export namespace networking {
    export namespace v1alpha3 {
        /**
         * Configuration affecting load balancing, outlier detection, etc. See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html
         */
        export interface DestinationRuleSpec {
            /**
             * A list of namespaces to which this destination rule is exported.
             */
            exportTo?: string[];
            /**
             * The name of a service from the service registry.
             */
            host: string;
            /**
             * One or more named sets that represent individual versions of a service.
             */
            subsets?: outputs.networking.v1alpha3.DestinationRuleSpecSubsets[];
            /**
             * Traffic policies to apply (load balancing policy, connection pool sizes, outlier detection).
             */
            trafficPolicy?: outputs.networking.v1alpha3.DestinationRuleSpecTrafficPolicy;
            /**
             * Criteria used to select the specific set of pods/VMs on which this `DestinationRule` configuration should be applied.
             */
            workloadSelector?: outputs.networking.v1alpha3.DestinationRuleSpecWorkloadSelector;
        }

        export interface DestinationRuleSpecSubsets {
            /**
             * Labels apply a filter over the endpoints of a service in the service registry.
             */
            labels?: {[key: string]: string};
            /**
             * Name of the subset.
             */
            name: string;
            /**
             * Traffic policies that apply to this subset.
             */
            trafficPolicy?: outputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficPolicy;
        }

        /**
         * Traffic policies that apply to this subset.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicy {
            connectionPool?: outputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficPolicyConnectionPool;
            /**
             * Settings controlling the load balancer algorithms.
             */
            loadBalancer?: any;
            outlierDetection?: outputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection;
            /**
             * Traffic policies specific to individual ports.
             */
            portLevelSettings?: outputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings[];
            /**
             * TLS related settings for connections to the upstream service.
             */
            tls?: outputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficPolicyTls;
            /**
             * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
             */
            tunnel?: outputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficPolicyTunnel;
        }

        export interface DestinationRuleSpecSubsetsTrafficPolicyConnectionPool {
            /**
             * HTTP connection pool settings.
             */
            http?: outputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: outputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: string;
            /**
             * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
             */
            http1MaxPendingRequests?: number;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: number;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: string;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: number;
            /**
             * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
             */
            maxRetries?: number;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: boolean;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: string;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: string;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: number;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: outputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: string;
            /**
             * Maximum number of keepalive probes to send without response before deciding the connection is dead.
             */
            probes?: number;
            /**
             * The time duration a connection needs to be idle before keep-alive probes start being sent.
             */
            time?: string;
        }

        export interface DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection {
            /**
             * Minimum ejection duration.
             */
            baseEjectionTime?: string;
            /**
             * Number of 5xx errors before a host is ejected from the connection pool.
             */
            consecutive5xxErrors?: number;
            consecutiveErrors?: number;
            /**
             * Number of gateway errors before a host is ejected from the connection pool.
             */
            consecutiveGatewayErrors?: number;
            /**
             * The number of consecutive locally originated failures before ejection occurs.
             */
            consecutiveLocalOriginFailures?: number;
            /**
             * Time interval between ejection sweep analysis.
             */
            interval?: string;
            /**
             * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
             */
            maxEjectionPercent?: number;
            /**
             * Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode.
             */
            minHealthPercent?: number;
            /**
             * Determines whether to distinguish local origin failures from external errors.
             */
            splitExternalLocalOriginErrors?: boolean;
        }

        export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings {
            connectionPool?: outputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool;
            /**
             * Settings controlling the load balancer algorithms.
             */
            loadBalancer?: any;
            outlierDetection?: outputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection;
            /**
             * Specifies the number of a port on the destination service on which this policy is being applied.
             */
            port?: outputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort;
            /**
             * TLS related settings for connections to the upstream service.
             */
            tls?: outputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls;
        }

        export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool {
            /**
             * HTTP connection pool settings.
             */
            http?: outputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: outputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: string;
            /**
             * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
             */
            http1MaxPendingRequests?: number;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: number;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: string;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: number;
            /**
             * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
             */
            maxRetries?: number;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: boolean;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: string;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: string;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: number;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: outputs.networking.v1alpha3.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: string;
            /**
             * Maximum number of keepalive probes to send without response before deciding the connection is dead.
             */
            probes?: number;
            /**
             * The time duration a connection needs to be idle before keep-alive probes start being sent.
             */
            time?: string;
        }

        export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection {
            /**
             * Minimum ejection duration.
             */
            baseEjectionTime?: string;
            /**
             * Number of 5xx errors before a host is ejected from the connection pool.
             */
            consecutive5xxErrors?: number;
            consecutiveErrors?: number;
            /**
             * Number of gateway errors before a host is ejected from the connection pool.
             */
            consecutiveGatewayErrors?: number;
            /**
             * The number of consecutive locally originated failures before ejection occurs.
             */
            consecutiveLocalOriginFailures?: number;
            /**
             * Time interval between ejection sweep analysis.
             */
            interval?: string;
            /**
             * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
             */
            maxEjectionPercent?: number;
            /**
             * Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode.
             */
            minHealthPercent?: number;
            /**
             * Determines whether to distinguish local origin failures from external errors.
             */
            splitExternalLocalOriginErrors?: boolean;
        }

        /**
         * Specifies the number of a port on the destination service on which this policy is being applied.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort {
            number?: number;
        }

        /**
         * TLS related settings for connections to the upstream service.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls {
            /**
             * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
             */
            caCertificates?: string;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            clientCertificate?: string;
            /**
             * The name of the secret that holds the TLS certs for the client including the CA certificates.
             */
            credentialName?: string;
            /**
             * InsecureSkipVerify specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
             */
            insecureSkipVerify?: boolean;
            /**
             * Indicates whether connections to this port should be secured using TLS.
             */
            mode?: string;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            privateKey?: string;
            /**
             * SNI string to present to the server during TLS handshake.
             */
            sni?: string;
            /**
             * A list of alternate names to verify the subject identity in the certificate.
             */
            subjectAltNames?: string[];
        }

        /**
         * TLS related settings for connections to the upstream service.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyTls {
            /**
             * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
             */
            caCertificates?: string;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            clientCertificate?: string;
            /**
             * The name of the secret that holds the TLS certs for the client including the CA certificates.
             */
            credentialName?: string;
            /**
             * InsecureSkipVerify specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
             */
            insecureSkipVerify?: boolean;
            /**
             * Indicates whether connections to this port should be secured using TLS.
             */
            mode?: string;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            privateKey?: string;
            /**
             * SNI string to present to the server during TLS handshake.
             */
            sni?: string;
            /**
             * A list of alternate names to verify the subject identity in the certificate.
             */
            subjectAltNames?: string[];
        }

        /**
         * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyTunnel {
            /**
             * Specifies which protocol to use for tunneling the downstream connection.
             */
            protocol?: string;
            /**
             * Specifies a host to which the downstream connection is tunneled.
             */
            targetHost: string;
            /**
             * Specifies a port to which the downstream connection is tunneled.
             */
            targetPort: number;
        }

        /**
         * Traffic policies to apply (load balancing policy, connection pool sizes, outlier detection).
         */
        export interface DestinationRuleSpecTrafficPolicy {
            connectionPool?: outputs.networking.v1alpha3.DestinationRuleSpecTrafficPolicyConnectionPool;
            /**
             * Settings controlling the load balancer algorithms.
             */
            loadBalancer?: any;
            outlierDetection?: outputs.networking.v1alpha3.DestinationRuleSpecTrafficPolicyOutlierDetection;
            /**
             * Traffic policies specific to individual ports.
             */
            portLevelSettings?: outputs.networking.v1alpha3.DestinationRuleSpecTrafficPolicyPortLevelSettings[];
            /**
             * TLS related settings for connections to the upstream service.
             */
            tls?: outputs.networking.v1alpha3.DestinationRuleSpecTrafficPolicyTls;
            /**
             * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
             */
            tunnel?: outputs.networking.v1alpha3.DestinationRuleSpecTrafficPolicyTunnel;
        }

        export interface DestinationRuleSpecTrafficPolicyConnectionPool {
            /**
             * HTTP connection pool settings.
             */
            http?: outputs.networking.v1alpha3.DestinationRuleSpecTrafficPolicyConnectionPoolHttp;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: outputs.networking.v1alpha3.DestinationRuleSpecTrafficPolicyConnectionPoolTcp;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface DestinationRuleSpecTrafficPolicyConnectionPoolHttp {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: string;
            /**
             * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
             */
            http1MaxPendingRequests?: number;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: number;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: string;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: number;
            /**
             * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
             */
            maxRetries?: number;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: boolean;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface DestinationRuleSpecTrafficPolicyConnectionPoolTcp {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: string;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: string;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: number;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: outputs.networking.v1alpha3.DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: string;
            /**
             * Maximum number of keepalive probes to send without response before deciding the connection is dead.
             */
            probes?: number;
            /**
             * The time duration a connection needs to be idle before keep-alive probes start being sent.
             */
            time?: string;
        }

        export interface DestinationRuleSpecTrafficPolicyOutlierDetection {
            /**
             * Minimum ejection duration.
             */
            baseEjectionTime?: string;
            /**
             * Number of 5xx errors before a host is ejected from the connection pool.
             */
            consecutive5xxErrors?: number;
            consecutiveErrors?: number;
            /**
             * Number of gateway errors before a host is ejected from the connection pool.
             */
            consecutiveGatewayErrors?: number;
            /**
             * The number of consecutive locally originated failures before ejection occurs.
             */
            consecutiveLocalOriginFailures?: number;
            /**
             * Time interval between ejection sweep analysis.
             */
            interval?: string;
            /**
             * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
             */
            maxEjectionPercent?: number;
            /**
             * Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode.
             */
            minHealthPercent?: number;
            /**
             * Determines whether to distinguish local origin failures from external errors.
             */
            splitExternalLocalOriginErrors?: boolean;
        }

        export interface DestinationRuleSpecTrafficPolicyPortLevelSettings {
            connectionPool?: outputs.networking.v1alpha3.DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool;
            /**
             * Settings controlling the load balancer algorithms.
             */
            loadBalancer?: any;
            outlierDetection?: outputs.networking.v1alpha3.DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection;
            /**
             * Specifies the number of a port on the destination service on which this policy is being applied.
             */
            port?: outputs.networking.v1alpha3.DestinationRuleSpecTrafficPolicyPortLevelSettingsPort;
            /**
             * TLS related settings for connections to the upstream service.
             */
            tls?: outputs.networking.v1alpha3.DestinationRuleSpecTrafficPolicyPortLevelSettingsTls;
        }

        export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool {
            /**
             * HTTP connection pool settings.
             */
            http?: outputs.networking.v1alpha3.DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: outputs.networking.v1alpha3.DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: string;
            /**
             * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
             */
            http1MaxPendingRequests?: number;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: number;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: string;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: number;
            /**
             * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
             */
            maxRetries?: number;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: boolean;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: string;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: string;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: number;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: outputs.networking.v1alpha3.DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: string;
            /**
             * Maximum number of keepalive probes to send without response before deciding the connection is dead.
             */
            probes?: number;
            /**
             * The time duration a connection needs to be idle before keep-alive probes start being sent.
             */
            time?: string;
        }

        export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection {
            /**
             * Minimum ejection duration.
             */
            baseEjectionTime?: string;
            /**
             * Number of 5xx errors before a host is ejected from the connection pool.
             */
            consecutive5xxErrors?: number;
            consecutiveErrors?: number;
            /**
             * Number of gateway errors before a host is ejected from the connection pool.
             */
            consecutiveGatewayErrors?: number;
            /**
             * The number of consecutive locally originated failures before ejection occurs.
             */
            consecutiveLocalOriginFailures?: number;
            /**
             * Time interval between ejection sweep analysis.
             */
            interval?: string;
            /**
             * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
             */
            maxEjectionPercent?: number;
            /**
             * Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode.
             */
            minHealthPercent?: number;
            /**
             * Determines whether to distinguish local origin failures from external errors.
             */
            splitExternalLocalOriginErrors?: boolean;
        }

        /**
         * Specifies the number of a port on the destination service on which this policy is being applied.
         */
        export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsPort {
            number?: number;
        }

        /**
         * TLS related settings for connections to the upstream service.
         */
        export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsTls {
            /**
             * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
             */
            caCertificates?: string;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            clientCertificate?: string;
            /**
             * The name of the secret that holds the TLS certs for the client including the CA certificates.
             */
            credentialName?: string;
            /**
             * InsecureSkipVerify specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
             */
            insecureSkipVerify?: boolean;
            /**
             * Indicates whether connections to this port should be secured using TLS.
             */
            mode?: string;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            privateKey?: string;
            /**
             * SNI string to present to the server during TLS handshake.
             */
            sni?: string;
            /**
             * A list of alternate names to verify the subject identity in the certificate.
             */
            subjectAltNames?: string[];
        }

        /**
         * TLS related settings for connections to the upstream service.
         */
        export interface DestinationRuleSpecTrafficPolicyTls {
            /**
             * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
             */
            caCertificates?: string;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            clientCertificate?: string;
            /**
             * The name of the secret that holds the TLS certs for the client including the CA certificates.
             */
            credentialName?: string;
            /**
             * InsecureSkipVerify specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
             */
            insecureSkipVerify?: boolean;
            /**
             * Indicates whether connections to this port should be secured using TLS.
             */
            mode?: string;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            privateKey?: string;
            /**
             * SNI string to present to the server during TLS handshake.
             */
            sni?: string;
            /**
             * A list of alternate names to verify the subject identity in the certificate.
             */
            subjectAltNames?: string[];
        }

        /**
         * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
         */
        export interface DestinationRuleSpecTrafficPolicyTunnel {
            /**
             * Specifies which protocol to use for tunneling the downstream connection.
             */
            protocol?: string;
            /**
             * Specifies a host to which the downstream connection is tunneled.
             */
            targetHost: string;
            /**
             * Specifies a port to which the downstream connection is tunneled.
             */
            targetPort: number;
        }

        /**
         * Criteria used to select the specific set of pods/VMs on which this `DestinationRule` configuration should be applied.
         */
        export interface DestinationRuleSpecWorkloadSelector {
            /**
             * One or more labels that indicate a specific set of pods/VMs on which a policy should be applied.
             */
            matchLabels?: {[key: string]: string};
        }

        /**
         * Customizing Envoy configuration generated by Istio. See more details at: https://istio.io/docs/reference/config/networking/envoy-filter.html
         */
        export interface EnvoyFilterSpec {
            /**
             * One or more patches with match conditions.
             */
            configPatches?: outputs.networking.v1alpha3.EnvoyFilterSpecConfigPatches[];
            /**
             * Priority defines the order in which patch sets are applied within a context.
             */
            priority?: number;
            /**
             * Criteria used to select the specific set of pods/VMs on which this patch configuration should be applied.
             */
            workloadSelector?: outputs.networking.v1alpha3.EnvoyFilterSpecWorkloadSelector;
        }

        export interface EnvoyFilterSpecConfigPatches {
            /**
             * Specifies where in the Envoy configuration, the patch should be applied.
             */
            applyTo?: string;
            /**
             * Match on listener/route configuration/cluster.
             */
            match?: any;
            /**
             * The patch to apply along with the operation.
             */
            patch?: outputs.networking.v1alpha3.EnvoyFilterSpecConfigPatchesPatch;
        }

        /**
         * The patch to apply along with the operation.
         */
        export interface EnvoyFilterSpecConfigPatchesPatch {
            /**
             * Determines the filter insertion order.
             */
            filterClass?: string;
            /**
             * Determines how the patch should be applied.
             */
            operation?: string;
            /**
             * The JSON config of the object being patched.
             */
            value?: {[key: string]: any};
        }

        /**
         * Criteria used to select the specific set of pods/VMs on which this patch configuration should be applied.
         */
        export interface EnvoyFilterSpecWorkloadSelector {
            /**
             * One or more labels that indicate a specific set of pods/VMs on which the configuration should be applied.
             */
            labels?: {[key: string]: string};
        }

        /**
         * Configuration affecting edge load balancer. See more details at: https://istio.io/docs/reference/config/networking/gateway.html
         */
        export interface GatewaySpec {
            /**
             * One or more labels that indicate a specific set of pods/VMs on which this gateway configuration should be applied.
             */
            selector?: {[key: string]: string};
            /**
             * A list of server specifications.
             */
            servers?: outputs.networking.v1alpha3.GatewaySpecServers[];
        }

        export interface GatewaySpecServers {
            /**
             * The ip or the Unix domain socket to which the listener should be bound to.
             */
            bind?: string;
            defaultEndpoint?: string;
            /**
             * One or more hosts exposed by this gateway.
             */
            hosts: string[];
            /**
             * An optional name of the server, when set must be unique across all servers.
             */
            name?: string;
            /**
             * The Port on which the proxy should listen for incoming connections.
             */
            port: outputs.networking.v1alpha3.GatewaySpecServersPort;
            /**
             * Set of TLS related options that govern the server's behavior.
             */
            tls?: outputs.networking.v1alpha3.GatewaySpecServersTls;
        }

        /**
         * The Port on which the proxy should listen for incoming connections.
         */
        export interface GatewaySpecServersPort {
            /**
             * Label assigned to the port.
             */
            name: string;
            /**
             * A valid non-negative integer port number.
             */
            number: number;
            /**
             * The protocol exposed on the port.
             */
            protocol: string;
            targetPort?: number;
        }

        /**
         * Set of TLS related options that govern the server's behavior.
         */
        export interface GatewaySpecServersTls {
            /**
             * REQUIRED if mode is `MUTUAL` or `OPTIONAL_MUTUAL`.
             */
            caCertificates?: string;
            /**
             * Optional: If specified, only support the specified cipher list.
             */
            cipherSuites?: string[];
            /**
             * For gateways running on Kubernetes, the name of the secret that holds the TLS certs including the CA certificates.
             */
            credentialName?: string;
            /**
             * If set to true, the load balancer will send a 301 redirect for all http connections, asking the clients to use HTTPS.
             */
            httpsRedirect?: boolean;
            /**
             * Optional: Maximum TLS protocol version.
             */
            maxProtocolVersion?: string;
            /**
             * Optional: Minimum TLS protocol version.
             */
            minProtocolVersion?: string;
            /**
             * Optional: Indicates whether connections to this port should be secured using TLS.
             */
            mode?: string;
            /**
             * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
             */
            privateKey?: string;
            /**
             * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
             */
            serverCertificate?: string;
            /**
             * A list of alternate names to verify the subject identity in the certificate presented by the client.
             */
            subjectAltNames?: string[];
            /**
             * An optional list of hex-encoded SHA-256 hashes of the authorized client certificates.
             */
            verifyCertificateHash?: string[];
            /**
             * An optional list of base64-encoded SHA-256 hashes of the SPKIs of authorized client certificates.
             */
            verifyCertificateSpki?: string[];
        }

        /**
         * Configuration affecting service registry. See more details at: https://istio.io/docs/reference/config/networking/service-entry.html
         */
        export interface ServiceEntrySpec {
            /**
             * The virtual IP addresses associated with the service.
             */
            addresses?: string[];
            /**
             * One or more endpoints associated with the service.
             */
            endpoints?: outputs.networking.v1alpha3.ServiceEntrySpecEndpoints[];
            /**
             * A list of namespaces to which this service is exported.
             */
            exportTo?: string[];
            /**
             * The hosts associated with the ServiceEntry.
             */
            hosts: string[];
            /**
             * Specify whether the service should be considered external to the mesh or part of the mesh.
             */
            location?: string;
            /**
             * The ports associated with the external service.
             */
            ports?: outputs.networking.v1alpha3.ServiceEntrySpecPorts[];
            /**
             * Service resolution mode for the hosts.
             */
            resolution?: string;
            /**
             * If specified, the proxy will verify that the server certificate's subject alternate name matches one of the specified values.
             */
            subjectAltNames?: string[];
            /**
             * Applicable only for MESH_INTERNAL services.
             */
            workloadSelector?: outputs.networking.v1alpha3.ServiceEntrySpecWorkloadSelector;
        }

        export interface ServiceEntrySpecEndpoints {
            /**
             * Address associated with the network endpoint without the port.
             */
            address?: string;
            /**
             * One or more labels associated with the endpoint.
             */
            labels?: {[key: string]: string};
            /**
             * The locality associated with the endpoint.
             */
            locality?: string;
            /**
             * Network enables Istio to group endpoints resident in the same L3 domain/network.
             */
            network?: string;
            /**
             * Set of ports associated with the endpoint.
             */
            ports?: {[key: string]: number};
            /**
             * The service account associated with the workload if a sidecar is present in the workload.
             */
            serviceAccount?: string;
            /**
             * The load balancing weight associated with the endpoint.
             */
            weight?: number;
        }

        export interface ServiceEntrySpecPorts {
            /**
             * Label assigned to the port.
             */
            name: string;
            /**
             * A valid non-negative integer port number.
             */
            number: number;
            /**
             * The protocol exposed on the port.
             */
            protocol?: string;
            /**
             * The port number on the endpoint where the traffic will be received.
             */
            targetPort?: number;
        }

        /**
         * Applicable only for MESH_INTERNAL services.
         */
        export interface ServiceEntrySpecWorkloadSelector {
            /**
             * One or more labels that indicate a specific set of pods/VMs on which the configuration should be applied.
             */
            labels?: {[key: string]: string};
        }

        /**
         * Configuration affecting network reachability of a sidecar. See more details at: https://istio.io/docs/reference/config/networking/sidecar.html
         */
        export interface SidecarSpec {
            /**
             * Egress specifies the configuration of the sidecar for processing outbound traffic from the attached workload instance to other services in the mesh.
             */
            egress?: outputs.networking.v1alpha3.SidecarSpecEgress[];
            /**
             * Settings controlling the volume of connections Envoy will accept from the network.
             */
            inboundConnectionPool?: outputs.networking.v1alpha3.SidecarSpecInboundConnectionPool;
            /**
             * Ingress specifies the configuration of the sidecar for processing inbound traffic to the attached workload instance.
             */
            ingress?: outputs.networking.v1alpha3.SidecarSpecIngress[];
            /**
             * Configuration for the outbound traffic policy.
             */
            outboundTrafficPolicy?: outputs.networking.v1alpha3.SidecarSpecOutboundTrafficPolicy;
            /**
             * Criteria used to select the specific set of pods/VMs on which this `Sidecar` configuration should be applied.
             */
            workloadSelector?: outputs.networking.v1alpha3.SidecarSpecWorkloadSelector;
        }

        export interface SidecarSpecEgress {
            /**
             * The IP(IPv4 or IPv6) or the Unix domain socket to which the listener should be bound to.
             */
            bind?: string;
            /**
             * When the bind address is an IP, the captureMode option dictates how traffic to the listener is expected to be captured (or not).
             */
            captureMode?: string;
            /**
             * One or more service hosts exposed by the listener in `namespace/dnsName` format.
             */
            hosts: string[];
            /**
             * The port associated with the listener.
             */
            port?: outputs.networking.v1alpha3.SidecarSpecEgressPort;
        }

        /**
         * The port associated with the listener.
         */
        export interface SidecarSpecEgressPort {
            /**
             * Label assigned to the port.
             */
            name?: string;
            /**
             * A valid non-negative integer port number.
             */
            number?: number;
            /**
             * The protocol exposed on the port.
             */
            protocol?: string;
            targetPort?: number;
        }

        /**
         * Settings controlling the volume of connections Envoy will accept from the network.
         */
        export interface SidecarSpecInboundConnectionPool {
            /**
             * HTTP connection pool settings.
             */
            http?: outputs.networking.v1alpha3.SidecarSpecInboundConnectionPoolHttp;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: outputs.networking.v1alpha3.SidecarSpecInboundConnectionPoolTcp;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface SidecarSpecInboundConnectionPoolHttp {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: string;
            /**
             * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
             */
            http1MaxPendingRequests?: number;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: number;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: string;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: number;
            /**
             * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
             */
            maxRetries?: number;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: boolean;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface SidecarSpecInboundConnectionPoolTcp {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: string;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: string;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: number;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: outputs.networking.v1alpha3.SidecarSpecInboundConnectionPoolTcpTcpKeepalive;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface SidecarSpecInboundConnectionPoolTcpTcpKeepalive {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: string;
            /**
             * Maximum number of keepalive probes to send without response before deciding the connection is dead.
             */
            probes?: number;
            /**
             * The time duration a connection needs to be idle before keep-alive probes start being sent.
             */
            time?: string;
        }

        export interface SidecarSpecIngress {
            /**
             * The IP(IPv4 or IPv6) to which the listener should be bound.
             */
            bind?: string;
            /**
             * The captureMode option dictates how traffic to the listener is expected to be captured (or not).
             */
            captureMode?: string;
            /**
             * Settings controlling the volume of connections Envoy will accept from the network.
             */
            connectionPool?: outputs.networking.v1alpha3.SidecarSpecIngressConnectionPool;
            /**
             * The IP endpoint or Unix domain socket to which traffic should be forwarded to.
             */
            defaultEndpoint?: string;
            /**
             * The port associated with the listener.
             */
            port: outputs.networking.v1alpha3.SidecarSpecIngressPort;
            /**
             * Set of TLS related options that will enable TLS termination on the sidecar for requests originating from outside the mesh.
             */
            tls?: outputs.networking.v1alpha3.SidecarSpecIngressTls;
        }

        /**
         * Settings controlling the volume of connections Envoy will accept from the network.
         */
        export interface SidecarSpecIngressConnectionPool {
            /**
             * HTTP connection pool settings.
             */
            http?: outputs.networking.v1alpha3.SidecarSpecIngressConnectionPoolHttp;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: outputs.networking.v1alpha3.SidecarSpecIngressConnectionPoolTcp;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface SidecarSpecIngressConnectionPoolHttp {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: string;
            /**
             * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
             */
            http1MaxPendingRequests?: number;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: number;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: string;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: number;
            /**
             * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
             */
            maxRetries?: number;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: boolean;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface SidecarSpecIngressConnectionPoolTcp {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: string;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: string;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: number;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: outputs.networking.v1alpha3.SidecarSpecIngressConnectionPoolTcpTcpKeepalive;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface SidecarSpecIngressConnectionPoolTcpTcpKeepalive {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: string;
            /**
             * Maximum number of keepalive probes to send without response before deciding the connection is dead.
             */
            probes?: number;
            /**
             * The time duration a connection needs to be idle before keep-alive probes start being sent.
             */
            time?: string;
        }

        /**
         * The port associated with the listener.
         */
        export interface SidecarSpecIngressPort {
            /**
             * Label assigned to the port.
             */
            name?: string;
            /**
             * A valid non-negative integer port number.
             */
            number?: number;
            /**
             * The protocol exposed on the port.
             */
            protocol?: string;
            targetPort?: number;
        }

        /**
         * Set of TLS related options that will enable TLS termination on the sidecar for requests originating from outside the mesh.
         */
        export interface SidecarSpecIngressTls {
            /**
             * REQUIRED if mode is `MUTUAL` or `OPTIONAL_MUTUAL`.
             */
            caCertificates?: string;
            /**
             * Optional: If specified, only support the specified cipher list.
             */
            cipherSuites?: string[];
            /**
             * For gateways running on Kubernetes, the name of the secret that holds the TLS certs including the CA certificates.
             */
            credentialName?: string;
            /**
             * If set to true, the load balancer will send a 301 redirect for all http connections, asking the clients to use HTTPS.
             */
            httpsRedirect?: boolean;
            /**
             * Optional: Maximum TLS protocol version.
             */
            maxProtocolVersion?: string;
            /**
             * Optional: Minimum TLS protocol version.
             */
            minProtocolVersion?: string;
            /**
             * Optional: Indicates whether connections to this port should be secured using TLS.
             */
            mode?: string;
            /**
             * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
             */
            privateKey?: string;
            /**
             * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
             */
            serverCertificate?: string;
            /**
             * A list of alternate names to verify the subject identity in the certificate presented by the client.
             */
            subjectAltNames?: string[];
            /**
             * An optional list of hex-encoded SHA-256 hashes of the authorized client certificates.
             */
            verifyCertificateHash?: string[];
            /**
             * An optional list of base64-encoded SHA-256 hashes of the SPKIs of authorized client certificates.
             */
            verifyCertificateSpki?: string[];
        }

        /**
         * Configuration for the outbound traffic policy.
         */
        export interface SidecarSpecOutboundTrafficPolicy {
            egressProxy?: outputs.networking.v1alpha3.SidecarSpecOutboundTrafficPolicyEgressProxy;
            mode?: string;
        }

        export interface SidecarSpecOutboundTrafficPolicyEgressProxy {
            /**
             * The name of a service from the service registry.
             */
            host: string;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: outputs.networking.v1alpha3.SidecarSpecOutboundTrafficPolicyEgressProxyPort;
            /**
             * The name of a subset within the service.
             */
            subset?: string;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface SidecarSpecOutboundTrafficPolicyEgressProxyPort {
            number?: number;
        }

        /**
         * Criteria used to select the specific set of pods/VMs on which this `Sidecar` configuration should be applied.
         */
        export interface SidecarSpecWorkloadSelector {
            /**
             * One or more labels that indicate a specific set of pods/VMs on which the configuration should be applied.
             */
            labels?: {[key: string]: string};
        }

        /**
         * Configuration affecting label/content routing, sni routing, etc. See more details at: https://istio.io/docs/reference/config/networking/virtual-service.html
         */
        export interface VirtualServiceSpec {
            /**
             * A list of namespaces to which this virtual service is exported.
             */
            exportTo?: string[];
            /**
             * The names of gateways and sidecars that should apply these routes.
             */
            gateways?: string[];
            /**
             * The destination hosts to which traffic is being sent.
             */
            hosts?: string[];
            /**
             * An ordered list of route rules for HTTP traffic.
             */
            http?: outputs.networking.v1alpha3.VirtualServiceSpecHttp[];
            /**
             * An ordered list of route rules for opaque TCP traffic.
             */
            tcp?: outputs.networking.v1alpha3.VirtualServiceSpecTcp[];
            /**
             * An ordered list of route rule for non-terminated TLS & HTTPS traffic.
             */
            tls?: outputs.networking.v1alpha3.VirtualServiceSpecTls[];
        }

        export interface VirtualServiceSpecHttp {
            /**
             * Cross-Origin Resource Sharing policy (CORS).
             */
            corsPolicy?: outputs.networking.v1alpha3.VirtualServiceSpecHttpCorsPolicy;
            /**
             * Delegate is used to specify the particular VirtualService which can be used to define delegate HTTPRoute.
             */
            delegate?: outputs.networking.v1alpha3.VirtualServiceSpecHttpDelegate;
            /**
             * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
             */
            directResponse?: outputs.networking.v1alpha3.VirtualServiceSpecHttpDirectResponse;
            /**
             * Fault injection policy to apply on HTTP traffic at the client side.
             */
            fault?: outputs.networking.v1alpha3.VirtualServiceSpecHttpFault;
            headers?: outputs.networking.v1alpha3.VirtualServiceSpecHttpHeaders;
            /**
             * Match conditions to be satisfied for the rule to be activated.
             */
            match?: outputs.networking.v1alpha3.VirtualServiceSpecHttpMatch[];
            /**
             * Mirror HTTP traffic to a another destination in addition to forwarding the requests to the intended destination.
             */
            mirror?: outputs.networking.v1alpha3.VirtualServiceSpecHttpMirror;
            mirrorPercent?: number;
            /**
             * Percentage of the traffic to be mirrored by the `mirror` field.
             */
            mirrorPercentage?: outputs.networking.v1alpha3.VirtualServiceSpecHttpMirrorPercentage;
            mirror_percent?: number;
            /**
             * Specifies the destinations to mirror HTTP traffic in addition to the original destination.
             */
            mirrors?: outputs.networking.v1alpha3.VirtualServiceSpecHttpMirrors[];
            /**
             * The name assigned to the route for debugging purposes.
             */
            name?: string;
            /**
             * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
             */
            redirect?: any;
            /**
             * Retry policy for HTTP requests.
             */
            retries?: outputs.networking.v1alpha3.VirtualServiceSpecHttpRetries;
            /**
             * Rewrite HTTP URIs and Authority headers.
             */
            rewrite?: outputs.networking.v1alpha3.VirtualServiceSpecHttpRewrite;
            /**
             * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
             */
            route?: outputs.networking.v1alpha3.VirtualServiceSpecHttpRoute[];
            /**
             * Timeout for HTTP requests, default is disabled.
             */
            timeout?: string;
        }

        /**
         * Cross-Origin Resource Sharing policy (CORS).
         */
        export interface VirtualServiceSpecHttpCorsPolicy {
            /**
             * Indicates whether the caller is allowed to send the actual request (not the preflight) using credentials.
             */
            allowCredentials?: boolean;
            /**
             * List of HTTP headers that can be used when requesting the resource.
             */
            allowHeaders?: string[];
            /**
             * List of HTTP methods allowed to access the resource.
             */
            allowMethods?: string[];
            allowOrigin?: string[];
            /**
             * String patterns that match allowed origins.
             */
            allowOrigins?: any[];
            /**
             * A list of HTTP headers that the browsers are allowed to access.
             */
            exposeHeaders?: string[];
            /**
             * Specifies how long the results of a preflight request can be cached.
             */
            maxAge?: string;
        }

        /**
         * Delegate is used to specify the particular VirtualService which can be used to define delegate HTTPRoute.
         */
        export interface VirtualServiceSpecHttpDelegate {
            /**
             * Name specifies the name of the delegate VirtualService.
             */
            name?: string;
            /**
             * Namespace specifies the namespace where the delegate VirtualService resides.
             */
            namespace?: string;
        }

        /**
         * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
         */
        export interface VirtualServiceSpecHttpDirectResponse {
            /**
             * Specifies the content of the response body.
             */
            body?: any;
            /**
             * Specifies the HTTP response status to be returned.
             */
            status: number;
        }

        /**
         * Fault injection policy to apply on HTTP traffic at the client side.
         */
        export interface VirtualServiceSpecHttpFault {
            /**
             * Abort Http request attempts and return error codes back to downstream service, giving the impression that the upstream service is faulty.
             */
            abort?: any;
            /**
             * Delay requests before forwarding, emulating various failures such as network issues, overloaded upstream service, etc.
             */
            delay?: any;
        }

        export interface VirtualServiceSpecHttpHeaders {
            request?: outputs.networking.v1alpha3.VirtualServiceSpecHttpHeadersRequest;
            response?: outputs.networking.v1alpha3.VirtualServiceSpecHttpHeadersResponse;
        }

        export interface VirtualServiceSpecHttpHeadersRequest {
            add?: {[key: string]: string};
            remove?: string[];
            set?: {[key: string]: string};
        }

        export interface VirtualServiceSpecHttpHeadersResponse {
            add?: {[key: string]: string};
            remove?: string[];
            set?: {[key: string]: string};
        }

        export interface VirtualServiceSpecHttpMatch {
            /**
             * HTTP Authority values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
             */
            authority?: any;
            /**
             * Names of gateways where the rule should be applied.
             */
            gateways?: string[];
            /**
             * The header keys must be lowercase and use hyphen as the separator, e.g.
             */
            headers?: {[key: string]: any};
            /**
             * Flag to specify whether the URI matching should be case-insensitive.
             */
            ignoreUriCase?: boolean;
            /**
             * HTTP Method values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
             */
            method?: any;
            /**
             * The name assigned to a match.
             */
            name?: string;
            /**
             * Specifies the ports on the host that is being addressed.
             */
            port?: number;
            /**
             * Query parameters for matching.
             */
            queryParams?: {[key: string]: any};
            /**
             * URI Scheme values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
             */
            scheme?: any;
            /**
             * One or more labels that constrain the applicability of a rule to source (client) workloads with the given labels.
             */
            sourceLabels?: {[key: string]: string};
            /**
             * Source namespace constraining the applicability of a rule to workloads in that namespace.
             */
            sourceNamespace?: string;
            /**
             * The human readable prefix to use when emitting statistics for this route.
             */
            statPrefix?: string;
            /**
             * URI to match values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
             */
            uri?: any;
            /**
             * withoutHeader has the same syntax with the header, but has opposite meaning.
             */
            withoutHeaders?: {[key: string]: any};
        }

        /**
         * Mirror HTTP traffic to a another destination in addition to forwarding the requests to the intended destination.
         */
        export interface VirtualServiceSpecHttpMirror {
            /**
             * The name of a service from the service registry.
             */
            host: string;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: outputs.networking.v1alpha3.VirtualServiceSpecHttpMirrorPort;
            /**
             * The name of a subset within the service.
             */
            subset?: string;
        }

        /**
         * Percentage of the traffic to be mirrored by the `mirror` field.
         */
        export interface VirtualServiceSpecHttpMirrorPercentage {
            value?: number;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecHttpMirrorPort {
            number?: number;
        }

        export interface VirtualServiceSpecHttpMirrors {
            /**
             * Destination specifies the target of the mirror operation.
             */
            destination: outputs.networking.v1alpha3.VirtualServiceSpecHttpMirrorsDestination;
            /**
             * Percentage of the traffic to be mirrored by the `destination` field.
             */
            percentage?: outputs.networking.v1alpha3.VirtualServiceSpecHttpMirrorsPercentage;
        }

        /**
         * Destination specifies the target of the mirror operation.
         */
        export interface VirtualServiceSpecHttpMirrorsDestination {
            /**
             * The name of a service from the service registry.
             */
            host: string;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: outputs.networking.v1alpha3.VirtualServiceSpecHttpMirrorsDestinationPort;
            /**
             * The name of a subset within the service.
             */
            subset?: string;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecHttpMirrorsDestinationPort {
            number?: number;
        }

        /**
         * Percentage of the traffic to be mirrored by the `destination` field.
         */
        export interface VirtualServiceSpecHttpMirrorsPercentage {
            value?: number;
        }

        /**
         * Retry policy for HTTP requests.
         */
        export interface VirtualServiceSpecHttpRetries {
            /**
             * Number of retries to be allowed for a given request.
             */
            attempts?: number;
            /**
             * Timeout per attempt for a given request, including the initial call and any retries.
             */
            perTryTimeout?: string;
            /**
             * Specifies the conditions under which retry takes place.
             */
            retryOn?: string;
            /**
             * Flag to specify whether the retries should retry to other localities.
             */
            retryRemoteLocalities?: boolean;
        }

        /**
         * Rewrite HTTP URIs and Authority headers.
         */
        export interface VirtualServiceSpecHttpRewrite {
            /**
             * rewrite the Authority/Host header with this value.
             */
            authority?: string;
            /**
             * rewrite the path (or the prefix) portion of the URI with this value.
             */
            uri?: string;
            /**
             * rewrite the path portion of the URI with the specified regex.
             */
            uriRegexRewrite?: outputs.networking.v1alpha3.VirtualServiceSpecHttpRewriteUriRegexRewrite;
        }

        /**
         * rewrite the path portion of the URI with the specified regex.
         */
        export interface VirtualServiceSpecHttpRewriteUriRegexRewrite {
            /**
             * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
             */
            match?: string;
            /**
             * The string that should replace into matching portions of original URI.
             */
            rewrite?: string;
        }

        export interface VirtualServiceSpecHttpRoute {
            /**
             * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
             */
            destination: outputs.networking.v1alpha3.VirtualServiceSpecHttpRouteDestination;
            headers?: outputs.networking.v1alpha3.VirtualServiceSpecHttpRouteHeaders;
            /**
             * Weight specifies the relative proportion of traffic to be forwarded to the destination.
             */
            weight?: number;
        }

        /**
         * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
         */
        export interface VirtualServiceSpecHttpRouteDestination {
            /**
             * The name of a service from the service registry.
             */
            host: string;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: outputs.networking.v1alpha3.VirtualServiceSpecHttpRouteDestinationPort;
            /**
             * The name of a subset within the service.
             */
            subset?: string;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecHttpRouteDestinationPort {
            number?: number;
        }

        export interface VirtualServiceSpecHttpRouteHeaders {
            request?: outputs.networking.v1alpha3.VirtualServiceSpecHttpRouteHeadersRequest;
            response?: outputs.networking.v1alpha3.VirtualServiceSpecHttpRouteHeadersResponse;
        }

        export interface VirtualServiceSpecHttpRouteHeadersRequest {
            add?: {[key: string]: string};
            remove?: string[];
            set?: {[key: string]: string};
        }

        export interface VirtualServiceSpecHttpRouteHeadersResponse {
            add?: {[key: string]: string};
            remove?: string[];
            set?: {[key: string]: string};
        }

        export interface VirtualServiceSpecTcp {
            /**
             * Match conditions to be satisfied for the rule to be activated.
             */
            match?: outputs.networking.v1alpha3.VirtualServiceSpecTcpMatch[];
            /**
             * The destination to which the connection should be forwarded to.
             */
            route?: outputs.networking.v1alpha3.VirtualServiceSpecTcpRoute[];
        }

        export interface VirtualServiceSpecTcpMatch {
            /**
             * IPv4 or IPv6 ip addresses of destination with optional subnet.
             */
            destinationSubnets?: string[];
            /**
             * Names of gateways where the rule should be applied.
             */
            gateways?: string[];
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: number;
            /**
             * One or more labels that constrain the applicability of a rule to workloads with the given labels.
             */
            sourceLabels?: {[key: string]: string};
            /**
             * Source namespace constraining the applicability of a rule to workloads in that namespace.
             */
            sourceNamespace?: string;
            sourceSubnet?: string;
        }

        export interface VirtualServiceSpecTcpRoute {
            /**
             * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
             */
            destination: outputs.networking.v1alpha3.VirtualServiceSpecTcpRouteDestination;
            /**
             * Weight specifies the relative proportion of traffic to be forwarded to the destination.
             */
            weight?: number;
        }

        /**
         * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
         */
        export interface VirtualServiceSpecTcpRouteDestination {
            /**
             * The name of a service from the service registry.
             */
            host: string;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: outputs.networking.v1alpha3.VirtualServiceSpecTcpRouteDestinationPort;
            /**
             * The name of a subset within the service.
             */
            subset?: string;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecTcpRouteDestinationPort {
            number?: number;
        }

        export interface VirtualServiceSpecTls {
            /**
             * Match conditions to be satisfied for the rule to be activated.
             */
            match: outputs.networking.v1alpha3.VirtualServiceSpecTlsMatch[];
            /**
             * The destination to which the connection should be forwarded to.
             */
            route?: outputs.networking.v1alpha3.VirtualServiceSpecTlsRoute[];
        }

        export interface VirtualServiceSpecTlsMatch {
            /**
             * IPv4 or IPv6 ip addresses of destination with optional subnet.
             */
            destinationSubnets?: string[];
            /**
             * Names of gateways where the rule should be applied.
             */
            gateways?: string[];
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: number;
            /**
             * SNI (server name indicator) to match on.
             */
            sniHosts: string[];
            /**
             * One or more labels that constrain the applicability of a rule to workloads with the given labels.
             */
            sourceLabels?: {[key: string]: string};
            /**
             * Source namespace constraining the applicability of a rule to workloads in that namespace.
             */
            sourceNamespace?: string;
        }

        export interface VirtualServiceSpecTlsRoute {
            /**
             * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
             */
            destination: outputs.networking.v1alpha3.VirtualServiceSpecTlsRouteDestination;
            /**
             * Weight specifies the relative proportion of traffic to be forwarded to the destination.
             */
            weight?: number;
        }

        /**
         * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
         */
        export interface VirtualServiceSpecTlsRouteDestination {
            /**
             * The name of a service from the service registry.
             */
            host: string;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: outputs.networking.v1alpha3.VirtualServiceSpecTlsRouteDestinationPort;
            /**
             * The name of a subset within the service.
             */
            subset?: string;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecTlsRouteDestinationPort {
            number?: number;
        }

        /**
         * Configuration affecting VMs onboarded into the mesh. See more details at: https://istio.io/docs/reference/config/networking/workload-entry.html
         */
        export interface WorkloadEntrySpec {
            /**
             * Address associated with the network endpoint without the port.
             */
            address?: string;
            /**
             * One or more labels associated with the endpoint.
             */
            labels?: {[key: string]: string};
            /**
             * The locality associated with the endpoint.
             */
            locality?: string;
            /**
             * Network enables Istio to group endpoints resident in the same L3 domain/network.
             */
            network?: string;
            /**
             * Set of ports associated with the endpoint.
             */
            ports?: {[key: string]: number};
            /**
             * The service account associated with the workload if a sidecar is present in the workload.
             */
            serviceAccount?: string;
            /**
             * The load balancing weight associated with the endpoint.
             */
            weight?: number;
        }

        /**
         * Describes a collection of workload instances. See more details at: https://istio.io/docs/reference/config/networking/workload-group.html
         */
        export interface WorkloadGroupSpec {
            /**
             * Metadata that will be used for all corresponding `WorkloadEntries`.
             */
            metadata?: outputs.networking.v1alpha3.WorkloadGroupSpecMetadata;
            /**
             * `ReadinessProbe` describes the configuration the user must provide for healthchecking on their workload.
             */
            probe?: any;
            /**
             * Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
             */
            template: outputs.networking.v1alpha3.WorkloadGroupSpecTemplate;
        }

        /**
         * Metadata that will be used for all corresponding `WorkloadEntries`.
         */
        export interface WorkloadGroupSpecMetadata {
            annotations?: {[key: string]: string};
            labels?: {[key: string]: string};
        }

        /**
         * Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
         */
        export interface WorkloadGroupSpecTemplate {
            /**
             * Address associated with the network endpoint without the port.
             */
            address?: string;
            /**
             * One or more labels associated with the endpoint.
             */
            labels?: {[key: string]: string};
            /**
             * The locality associated with the endpoint.
             */
            locality?: string;
            /**
             * Network enables Istio to group endpoints resident in the same L3 domain/network.
             */
            network?: string;
            /**
             * Set of ports associated with the endpoint.
             */
            ports?: {[key: string]: number};
            /**
             * The service account associated with the workload if a sidecar is present in the workload.
             */
            serviceAccount?: string;
            /**
             * The load balancing weight associated with the endpoint.
             */
            weight?: number;
        }

    }

    export namespace v1beta1 {
        /**
         * Configuration affecting load balancing, outlier detection, etc. See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html
         */
        export interface DestinationRuleSpec {
            /**
             * A list of namespaces to which this destination rule is exported.
             */
            exportTo?: string[];
            /**
             * The name of a service from the service registry.
             */
            host: string;
            /**
             * One or more named sets that represent individual versions of a service.
             */
            subsets?: outputs.networking.v1beta1.DestinationRuleSpecSubsets[];
            /**
             * Traffic policies to apply (load balancing policy, connection pool sizes, outlier detection).
             */
            trafficPolicy?: outputs.networking.v1beta1.DestinationRuleSpecTrafficPolicy;
            /**
             * Criteria used to select the specific set of pods/VMs on which this `DestinationRule` configuration should be applied.
             */
            workloadSelector?: outputs.networking.v1beta1.DestinationRuleSpecWorkloadSelector;
        }

        export interface DestinationRuleSpecSubsets {
            /**
             * Labels apply a filter over the endpoints of a service in the service registry.
             */
            labels?: {[key: string]: string};
            /**
             * Name of the subset.
             */
            name: string;
            /**
             * Traffic policies that apply to this subset.
             */
            trafficPolicy?: outputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficPolicy;
        }

        /**
         * Traffic policies that apply to this subset.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicy {
            connectionPool?: outputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficPolicyConnectionPool;
            /**
             * Settings controlling the load balancer algorithms.
             */
            loadBalancer?: any;
            outlierDetection?: outputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection;
            /**
             * Traffic policies specific to individual ports.
             */
            portLevelSettings?: outputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings[];
            /**
             * TLS related settings for connections to the upstream service.
             */
            tls?: outputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficPolicyTls;
            /**
             * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
             */
            tunnel?: outputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficPolicyTunnel;
        }

        export interface DestinationRuleSpecSubsetsTrafficPolicyConnectionPool {
            /**
             * HTTP connection pool settings.
             */
            http?: outputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: outputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: string;
            /**
             * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
             */
            http1MaxPendingRequests?: number;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: number;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: string;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: number;
            /**
             * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
             */
            maxRetries?: number;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: boolean;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: string;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: string;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: number;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: outputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: string;
            /**
             * Maximum number of keepalive probes to send without response before deciding the connection is dead.
             */
            probes?: number;
            /**
             * The time duration a connection needs to be idle before keep-alive probes start being sent.
             */
            time?: string;
        }

        export interface DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection {
            /**
             * Minimum ejection duration.
             */
            baseEjectionTime?: string;
            /**
             * Number of 5xx errors before a host is ejected from the connection pool.
             */
            consecutive5xxErrors?: number;
            consecutiveErrors?: number;
            /**
             * Number of gateway errors before a host is ejected from the connection pool.
             */
            consecutiveGatewayErrors?: number;
            /**
             * The number of consecutive locally originated failures before ejection occurs.
             */
            consecutiveLocalOriginFailures?: number;
            /**
             * Time interval between ejection sweep analysis.
             */
            interval?: string;
            /**
             * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
             */
            maxEjectionPercent?: number;
            /**
             * Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode.
             */
            minHealthPercent?: number;
            /**
             * Determines whether to distinguish local origin failures from external errors.
             */
            splitExternalLocalOriginErrors?: boolean;
        }

        export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings {
            connectionPool?: outputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool;
            /**
             * Settings controlling the load balancer algorithms.
             */
            loadBalancer?: any;
            outlierDetection?: outputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection;
            /**
             * Specifies the number of a port on the destination service on which this policy is being applied.
             */
            port?: outputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort;
            /**
             * TLS related settings for connections to the upstream service.
             */
            tls?: outputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls;
        }

        export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool {
            /**
             * HTTP connection pool settings.
             */
            http?: outputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: outputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: string;
            /**
             * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
             */
            http1MaxPendingRequests?: number;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: number;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: string;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: number;
            /**
             * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
             */
            maxRetries?: number;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: boolean;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: string;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: string;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: number;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: outputs.networking.v1beta1.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: string;
            /**
             * Maximum number of keepalive probes to send without response before deciding the connection is dead.
             */
            probes?: number;
            /**
             * The time duration a connection needs to be idle before keep-alive probes start being sent.
             */
            time?: string;
        }

        export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection {
            /**
             * Minimum ejection duration.
             */
            baseEjectionTime?: string;
            /**
             * Number of 5xx errors before a host is ejected from the connection pool.
             */
            consecutive5xxErrors?: number;
            consecutiveErrors?: number;
            /**
             * Number of gateway errors before a host is ejected from the connection pool.
             */
            consecutiveGatewayErrors?: number;
            /**
             * The number of consecutive locally originated failures before ejection occurs.
             */
            consecutiveLocalOriginFailures?: number;
            /**
             * Time interval between ejection sweep analysis.
             */
            interval?: string;
            /**
             * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
             */
            maxEjectionPercent?: number;
            /**
             * Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode.
             */
            minHealthPercent?: number;
            /**
             * Determines whether to distinguish local origin failures from external errors.
             */
            splitExternalLocalOriginErrors?: boolean;
        }

        /**
         * Specifies the number of a port on the destination service on which this policy is being applied.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort {
            number?: number;
        }

        /**
         * TLS related settings for connections to the upstream service.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls {
            /**
             * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
             */
            caCertificates?: string;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            clientCertificate?: string;
            /**
             * The name of the secret that holds the TLS certs for the client including the CA certificates.
             */
            credentialName?: string;
            /**
             * InsecureSkipVerify specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
             */
            insecureSkipVerify?: boolean;
            /**
             * Indicates whether connections to this port should be secured using TLS.
             */
            mode?: string;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            privateKey?: string;
            /**
             * SNI string to present to the server during TLS handshake.
             */
            sni?: string;
            /**
             * A list of alternate names to verify the subject identity in the certificate.
             */
            subjectAltNames?: string[];
        }

        /**
         * TLS related settings for connections to the upstream service.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyTls {
            /**
             * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
             */
            caCertificates?: string;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            clientCertificate?: string;
            /**
             * The name of the secret that holds the TLS certs for the client including the CA certificates.
             */
            credentialName?: string;
            /**
             * InsecureSkipVerify specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
             */
            insecureSkipVerify?: boolean;
            /**
             * Indicates whether connections to this port should be secured using TLS.
             */
            mode?: string;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            privateKey?: string;
            /**
             * SNI string to present to the server during TLS handshake.
             */
            sni?: string;
            /**
             * A list of alternate names to verify the subject identity in the certificate.
             */
            subjectAltNames?: string[];
        }

        /**
         * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
         */
        export interface DestinationRuleSpecSubsetsTrafficPolicyTunnel {
            /**
             * Specifies which protocol to use for tunneling the downstream connection.
             */
            protocol?: string;
            /**
             * Specifies a host to which the downstream connection is tunneled.
             */
            targetHost: string;
            /**
             * Specifies a port to which the downstream connection is tunneled.
             */
            targetPort: number;
        }

        /**
         * Traffic policies to apply (load balancing policy, connection pool sizes, outlier detection).
         */
        export interface DestinationRuleSpecTrafficPolicy {
            connectionPool?: outputs.networking.v1beta1.DestinationRuleSpecTrafficPolicyConnectionPool;
            /**
             * Settings controlling the load balancer algorithms.
             */
            loadBalancer?: any;
            outlierDetection?: outputs.networking.v1beta1.DestinationRuleSpecTrafficPolicyOutlierDetection;
            /**
             * Traffic policies specific to individual ports.
             */
            portLevelSettings?: outputs.networking.v1beta1.DestinationRuleSpecTrafficPolicyPortLevelSettings[];
            /**
             * TLS related settings for connections to the upstream service.
             */
            tls?: outputs.networking.v1beta1.DestinationRuleSpecTrafficPolicyTls;
            /**
             * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
             */
            tunnel?: outputs.networking.v1beta1.DestinationRuleSpecTrafficPolicyTunnel;
        }

        export interface DestinationRuleSpecTrafficPolicyConnectionPool {
            /**
             * HTTP connection pool settings.
             */
            http?: outputs.networking.v1beta1.DestinationRuleSpecTrafficPolicyConnectionPoolHttp;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: outputs.networking.v1beta1.DestinationRuleSpecTrafficPolicyConnectionPoolTcp;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface DestinationRuleSpecTrafficPolicyConnectionPoolHttp {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: string;
            /**
             * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
             */
            http1MaxPendingRequests?: number;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: number;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: string;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: number;
            /**
             * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
             */
            maxRetries?: number;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: boolean;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface DestinationRuleSpecTrafficPolicyConnectionPoolTcp {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: string;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: string;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: number;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: outputs.networking.v1beta1.DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: string;
            /**
             * Maximum number of keepalive probes to send without response before deciding the connection is dead.
             */
            probes?: number;
            /**
             * The time duration a connection needs to be idle before keep-alive probes start being sent.
             */
            time?: string;
        }

        export interface DestinationRuleSpecTrafficPolicyOutlierDetection {
            /**
             * Minimum ejection duration.
             */
            baseEjectionTime?: string;
            /**
             * Number of 5xx errors before a host is ejected from the connection pool.
             */
            consecutive5xxErrors?: number;
            consecutiveErrors?: number;
            /**
             * Number of gateway errors before a host is ejected from the connection pool.
             */
            consecutiveGatewayErrors?: number;
            /**
             * The number of consecutive locally originated failures before ejection occurs.
             */
            consecutiveLocalOriginFailures?: number;
            /**
             * Time interval between ejection sweep analysis.
             */
            interval?: string;
            /**
             * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
             */
            maxEjectionPercent?: number;
            /**
             * Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode.
             */
            minHealthPercent?: number;
            /**
             * Determines whether to distinguish local origin failures from external errors.
             */
            splitExternalLocalOriginErrors?: boolean;
        }

        export interface DestinationRuleSpecTrafficPolicyPortLevelSettings {
            connectionPool?: outputs.networking.v1beta1.DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool;
            /**
             * Settings controlling the load balancer algorithms.
             */
            loadBalancer?: any;
            outlierDetection?: outputs.networking.v1beta1.DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection;
            /**
             * Specifies the number of a port on the destination service on which this policy is being applied.
             */
            port?: outputs.networking.v1beta1.DestinationRuleSpecTrafficPolicyPortLevelSettingsPort;
            /**
             * TLS related settings for connections to the upstream service.
             */
            tls?: outputs.networking.v1beta1.DestinationRuleSpecTrafficPolicyPortLevelSettingsTls;
        }

        export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool {
            /**
             * HTTP connection pool settings.
             */
            http?: outputs.networking.v1beta1.DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: outputs.networking.v1beta1.DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: string;
            /**
             * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
             */
            http1MaxPendingRequests?: number;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: number;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: string;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: number;
            /**
             * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
             */
            maxRetries?: number;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: boolean;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: string;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: string;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: number;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: outputs.networking.v1beta1.DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: string;
            /**
             * Maximum number of keepalive probes to send without response before deciding the connection is dead.
             */
            probes?: number;
            /**
             * The time duration a connection needs to be idle before keep-alive probes start being sent.
             */
            time?: string;
        }

        export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection {
            /**
             * Minimum ejection duration.
             */
            baseEjectionTime?: string;
            /**
             * Number of 5xx errors before a host is ejected from the connection pool.
             */
            consecutive5xxErrors?: number;
            consecutiveErrors?: number;
            /**
             * Number of gateway errors before a host is ejected from the connection pool.
             */
            consecutiveGatewayErrors?: number;
            /**
             * The number of consecutive locally originated failures before ejection occurs.
             */
            consecutiveLocalOriginFailures?: number;
            /**
             * Time interval between ejection sweep analysis.
             */
            interval?: string;
            /**
             * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
             */
            maxEjectionPercent?: number;
            /**
             * Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode.
             */
            minHealthPercent?: number;
            /**
             * Determines whether to distinguish local origin failures from external errors.
             */
            splitExternalLocalOriginErrors?: boolean;
        }

        /**
         * Specifies the number of a port on the destination service on which this policy is being applied.
         */
        export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsPort {
            number?: number;
        }

        /**
         * TLS related settings for connections to the upstream service.
         */
        export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsTls {
            /**
             * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
             */
            caCertificates?: string;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            clientCertificate?: string;
            /**
             * The name of the secret that holds the TLS certs for the client including the CA certificates.
             */
            credentialName?: string;
            /**
             * InsecureSkipVerify specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
             */
            insecureSkipVerify?: boolean;
            /**
             * Indicates whether connections to this port should be secured using TLS.
             */
            mode?: string;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            privateKey?: string;
            /**
             * SNI string to present to the server during TLS handshake.
             */
            sni?: string;
            /**
             * A list of alternate names to verify the subject identity in the certificate.
             */
            subjectAltNames?: string[];
        }

        /**
         * TLS related settings for connections to the upstream service.
         */
        export interface DestinationRuleSpecTrafficPolicyTls {
            /**
             * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
             */
            caCertificates?: string;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            clientCertificate?: string;
            /**
             * The name of the secret that holds the TLS certs for the client including the CA certificates.
             */
            credentialName?: string;
            /**
             * InsecureSkipVerify specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
             */
            insecureSkipVerify?: boolean;
            /**
             * Indicates whether connections to this port should be secured using TLS.
             */
            mode?: string;
            /**
             * REQUIRED if mode is `MUTUAL`.
             */
            privateKey?: string;
            /**
             * SNI string to present to the server during TLS handshake.
             */
            sni?: string;
            /**
             * A list of alternate names to verify the subject identity in the certificate.
             */
            subjectAltNames?: string[];
        }

        /**
         * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
         */
        export interface DestinationRuleSpecTrafficPolicyTunnel {
            /**
             * Specifies which protocol to use for tunneling the downstream connection.
             */
            protocol?: string;
            /**
             * Specifies a host to which the downstream connection is tunneled.
             */
            targetHost: string;
            /**
             * Specifies a port to which the downstream connection is tunneled.
             */
            targetPort: number;
        }

        /**
         * Criteria used to select the specific set of pods/VMs on which this `DestinationRule` configuration should be applied.
         */
        export interface DestinationRuleSpecWorkloadSelector {
            /**
             * One or more labels that indicate a specific set of pods/VMs on which a policy should be applied.
             */
            matchLabels?: {[key: string]: string};
        }

        /**
         * Configuration affecting edge load balancer. See more details at: https://istio.io/docs/reference/config/networking/gateway.html
         */
        export interface GatewaySpec {
            /**
             * One or more labels that indicate a specific set of pods/VMs on which this gateway configuration should be applied.
             */
            selector?: {[key: string]: string};
            /**
             * A list of server specifications.
             */
            servers?: outputs.networking.v1beta1.GatewaySpecServers[];
        }

        export interface GatewaySpecServers {
            /**
             * The ip or the Unix domain socket to which the listener should be bound to.
             */
            bind?: string;
            defaultEndpoint?: string;
            /**
             * One or more hosts exposed by this gateway.
             */
            hosts: string[];
            /**
             * An optional name of the server, when set must be unique across all servers.
             */
            name?: string;
            /**
             * The Port on which the proxy should listen for incoming connections.
             */
            port: outputs.networking.v1beta1.GatewaySpecServersPort;
            /**
             * Set of TLS related options that govern the server's behavior.
             */
            tls?: outputs.networking.v1beta1.GatewaySpecServersTls;
        }

        /**
         * The Port on which the proxy should listen for incoming connections.
         */
        export interface GatewaySpecServersPort {
            /**
             * Label assigned to the port.
             */
            name: string;
            /**
             * A valid non-negative integer port number.
             */
            number: number;
            /**
             * The protocol exposed on the port.
             */
            protocol: string;
            targetPort?: number;
        }

        /**
         * Set of TLS related options that govern the server's behavior.
         */
        export interface GatewaySpecServersTls {
            /**
             * REQUIRED if mode is `MUTUAL` or `OPTIONAL_MUTUAL`.
             */
            caCertificates?: string;
            /**
             * Optional: If specified, only support the specified cipher list.
             */
            cipherSuites?: string[];
            /**
             * For gateways running on Kubernetes, the name of the secret that holds the TLS certs including the CA certificates.
             */
            credentialName?: string;
            /**
             * If set to true, the load balancer will send a 301 redirect for all http connections, asking the clients to use HTTPS.
             */
            httpsRedirect?: boolean;
            /**
             * Optional: Maximum TLS protocol version.
             */
            maxProtocolVersion?: string;
            /**
             * Optional: Minimum TLS protocol version.
             */
            minProtocolVersion?: string;
            /**
             * Optional: Indicates whether connections to this port should be secured using TLS.
             */
            mode?: string;
            /**
             * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
             */
            privateKey?: string;
            /**
             * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
             */
            serverCertificate?: string;
            /**
             * A list of alternate names to verify the subject identity in the certificate presented by the client.
             */
            subjectAltNames?: string[];
            /**
             * An optional list of hex-encoded SHA-256 hashes of the authorized client certificates.
             */
            verifyCertificateHash?: string[];
            /**
             * An optional list of base64-encoded SHA-256 hashes of the SPKIs of authorized client certificates.
             */
            verifyCertificateSpki?: string[];
        }

        /**
         * Provides configuration for individual workloads. See more details at: https://istio.io/docs/reference/config/networking/proxy-config.html
         */
        export interface ProxyConfigSpec {
            /**
             * The number of worker threads to run.
             */
            concurrency?: number;
            /**
             * Additional environment variables for the proxy.
             */
            environmentVariables?: {[key: string]: string};
            /**
             * Specifies the details of the proxy image.
             */
            image?: outputs.networking.v1beta1.ProxyConfigSpecImage;
            /**
             * Optional.
             */
            selector?: outputs.networking.v1beta1.ProxyConfigSpecSelector;
        }

        /**
         * Specifies the details of the proxy image.
         */
        export interface ProxyConfigSpecImage {
            /**
             * The image type of the image.
             */
            imageType?: string;
        }

        /**
         * Optional.
         */
        export interface ProxyConfigSpecSelector {
            /**
             * One or more labels that indicate a specific set of pods/VMs on which a policy should be applied.
             */
            matchLabels?: {[key: string]: string};
        }

        /**
         * Configuration affecting service registry. See more details at: https://istio.io/docs/reference/config/networking/service-entry.html
         */
        export interface ServiceEntrySpec {
            /**
             * The virtual IP addresses associated with the service.
             */
            addresses?: string[];
            /**
             * One or more endpoints associated with the service.
             */
            endpoints?: outputs.networking.v1beta1.ServiceEntrySpecEndpoints[];
            /**
             * A list of namespaces to which this service is exported.
             */
            exportTo?: string[];
            /**
             * The hosts associated with the ServiceEntry.
             */
            hosts: string[];
            /**
             * Specify whether the service should be considered external to the mesh or part of the mesh.
             */
            location?: string;
            /**
             * The ports associated with the external service.
             */
            ports?: outputs.networking.v1beta1.ServiceEntrySpecPorts[];
            /**
             * Service resolution mode for the hosts.
             */
            resolution?: string;
            /**
             * If specified, the proxy will verify that the server certificate's subject alternate name matches one of the specified values.
             */
            subjectAltNames?: string[];
            /**
             * Applicable only for MESH_INTERNAL services.
             */
            workloadSelector?: outputs.networking.v1beta1.ServiceEntrySpecWorkloadSelector;
        }

        export interface ServiceEntrySpecEndpoints {
            /**
             * Address associated with the network endpoint without the port.
             */
            address?: string;
            /**
             * One or more labels associated with the endpoint.
             */
            labels?: {[key: string]: string};
            /**
             * The locality associated with the endpoint.
             */
            locality?: string;
            /**
             * Network enables Istio to group endpoints resident in the same L3 domain/network.
             */
            network?: string;
            /**
             * Set of ports associated with the endpoint.
             */
            ports?: {[key: string]: number};
            /**
             * The service account associated with the workload if a sidecar is present in the workload.
             */
            serviceAccount?: string;
            /**
             * The load balancing weight associated with the endpoint.
             */
            weight?: number;
        }

        export interface ServiceEntrySpecPorts {
            /**
             * Label assigned to the port.
             */
            name: string;
            /**
             * A valid non-negative integer port number.
             */
            number: number;
            /**
             * The protocol exposed on the port.
             */
            protocol?: string;
            /**
             * The port number on the endpoint where the traffic will be received.
             */
            targetPort?: number;
        }

        /**
         * Applicable only for MESH_INTERNAL services.
         */
        export interface ServiceEntrySpecWorkloadSelector {
            /**
             * One or more labels that indicate a specific set of pods/VMs on which the configuration should be applied.
             */
            labels?: {[key: string]: string};
        }

        /**
         * Configuration affecting network reachability of a sidecar. See more details at: https://istio.io/docs/reference/config/networking/sidecar.html
         */
        export interface SidecarSpec {
            /**
             * Egress specifies the configuration of the sidecar for processing outbound traffic from the attached workload instance to other services in the mesh.
             */
            egress?: outputs.networking.v1beta1.SidecarSpecEgress[];
            /**
             * Settings controlling the volume of connections Envoy will accept from the network.
             */
            inboundConnectionPool?: outputs.networking.v1beta1.SidecarSpecInboundConnectionPool;
            /**
             * Ingress specifies the configuration of the sidecar for processing inbound traffic to the attached workload instance.
             */
            ingress?: outputs.networking.v1beta1.SidecarSpecIngress[];
            /**
             * Configuration for the outbound traffic policy.
             */
            outboundTrafficPolicy?: outputs.networking.v1beta1.SidecarSpecOutboundTrafficPolicy;
            /**
             * Criteria used to select the specific set of pods/VMs on which this `Sidecar` configuration should be applied.
             */
            workloadSelector?: outputs.networking.v1beta1.SidecarSpecWorkloadSelector;
        }

        export interface SidecarSpecEgress {
            /**
             * The IP(IPv4 or IPv6) or the Unix domain socket to which the listener should be bound to.
             */
            bind?: string;
            /**
             * When the bind address is an IP, the captureMode option dictates how traffic to the listener is expected to be captured (or not).
             */
            captureMode?: string;
            /**
             * One or more service hosts exposed by the listener in `namespace/dnsName` format.
             */
            hosts: string[];
            /**
             * The port associated with the listener.
             */
            port?: outputs.networking.v1beta1.SidecarSpecEgressPort;
        }

        /**
         * The port associated with the listener.
         */
        export interface SidecarSpecEgressPort {
            /**
             * Label assigned to the port.
             */
            name?: string;
            /**
             * A valid non-negative integer port number.
             */
            number?: number;
            /**
             * The protocol exposed on the port.
             */
            protocol?: string;
            targetPort?: number;
        }

        /**
         * Settings controlling the volume of connections Envoy will accept from the network.
         */
        export interface SidecarSpecInboundConnectionPool {
            /**
             * HTTP connection pool settings.
             */
            http?: outputs.networking.v1beta1.SidecarSpecInboundConnectionPoolHttp;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: outputs.networking.v1beta1.SidecarSpecInboundConnectionPoolTcp;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface SidecarSpecInboundConnectionPoolHttp {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: string;
            /**
             * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
             */
            http1MaxPendingRequests?: number;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: number;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: string;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: number;
            /**
             * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
             */
            maxRetries?: number;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: boolean;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface SidecarSpecInboundConnectionPoolTcp {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: string;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: string;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: number;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: outputs.networking.v1beta1.SidecarSpecInboundConnectionPoolTcpTcpKeepalive;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface SidecarSpecInboundConnectionPoolTcpTcpKeepalive {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: string;
            /**
             * Maximum number of keepalive probes to send without response before deciding the connection is dead.
             */
            probes?: number;
            /**
             * The time duration a connection needs to be idle before keep-alive probes start being sent.
             */
            time?: string;
        }

        export interface SidecarSpecIngress {
            /**
             * The IP(IPv4 or IPv6) to which the listener should be bound.
             */
            bind?: string;
            /**
             * The captureMode option dictates how traffic to the listener is expected to be captured (or not).
             */
            captureMode?: string;
            /**
             * Settings controlling the volume of connections Envoy will accept from the network.
             */
            connectionPool?: outputs.networking.v1beta1.SidecarSpecIngressConnectionPool;
            /**
             * The IP endpoint or Unix domain socket to which traffic should be forwarded to.
             */
            defaultEndpoint?: string;
            /**
             * The port associated with the listener.
             */
            port: outputs.networking.v1beta1.SidecarSpecIngressPort;
            /**
             * Set of TLS related options that will enable TLS termination on the sidecar for requests originating from outside the mesh.
             */
            tls?: outputs.networking.v1beta1.SidecarSpecIngressTls;
        }

        /**
         * Settings controlling the volume of connections Envoy will accept from the network.
         */
        export interface SidecarSpecIngressConnectionPool {
            /**
             * HTTP connection pool settings.
             */
            http?: outputs.networking.v1beta1.SidecarSpecIngressConnectionPoolHttp;
            /**
             * Settings common to both HTTP and TCP upstream connections.
             */
            tcp?: outputs.networking.v1beta1.SidecarSpecIngressConnectionPoolTcp;
        }

        /**
         * HTTP connection pool settings.
         */
        export interface SidecarSpecIngressConnectionPoolHttp {
            /**
             * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
             */
            h2UpgradePolicy?: string;
            /**
             * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
             */
            http1MaxPendingRequests?: number;
            /**
             * Maximum number of active requests to a destination.
             */
            http2MaxRequests?: number;
            /**
             * The idle timeout for upstream connection pool connections.
             */
            idleTimeout?: string;
            /**
             * Maximum number of requests per connection to a backend.
             */
            maxRequestsPerConnection?: number;
            /**
             * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
             */
            maxRetries?: number;
            /**
             * If set to true, client protocol will be preserved while initiating connection to backend.
             */
            useClientProtocol?: boolean;
        }

        /**
         * Settings common to both HTTP and TCP upstream connections.
         */
        export interface SidecarSpecIngressConnectionPoolTcp {
            /**
             * TCP connection timeout.
             */
            connectTimeout?: string;
            /**
             * The maximum duration of a connection.
             */
            maxConnectionDuration?: string;
            /**
             * Maximum number of HTTP1 /TCP connections to a destination host.
             */
            maxConnections?: number;
            /**
             * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
             */
            tcpKeepalive?: outputs.networking.v1beta1.SidecarSpecIngressConnectionPoolTcpTcpKeepalive;
        }

        /**
         * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
         */
        export interface SidecarSpecIngressConnectionPoolTcpTcpKeepalive {
            /**
             * The time duration between keep-alive probes.
             */
            interval?: string;
            /**
             * Maximum number of keepalive probes to send without response before deciding the connection is dead.
             */
            probes?: number;
            /**
             * The time duration a connection needs to be idle before keep-alive probes start being sent.
             */
            time?: string;
        }

        /**
         * The port associated with the listener.
         */
        export interface SidecarSpecIngressPort {
            /**
             * Label assigned to the port.
             */
            name?: string;
            /**
             * A valid non-negative integer port number.
             */
            number?: number;
            /**
             * The protocol exposed on the port.
             */
            protocol?: string;
            targetPort?: number;
        }

        /**
         * Set of TLS related options that will enable TLS termination on the sidecar for requests originating from outside the mesh.
         */
        export interface SidecarSpecIngressTls {
            /**
             * REQUIRED if mode is `MUTUAL` or `OPTIONAL_MUTUAL`.
             */
            caCertificates?: string;
            /**
             * Optional: If specified, only support the specified cipher list.
             */
            cipherSuites?: string[];
            /**
             * For gateways running on Kubernetes, the name of the secret that holds the TLS certs including the CA certificates.
             */
            credentialName?: string;
            /**
             * If set to true, the load balancer will send a 301 redirect for all http connections, asking the clients to use HTTPS.
             */
            httpsRedirect?: boolean;
            /**
             * Optional: Maximum TLS protocol version.
             */
            maxProtocolVersion?: string;
            /**
             * Optional: Minimum TLS protocol version.
             */
            minProtocolVersion?: string;
            /**
             * Optional: Indicates whether connections to this port should be secured using TLS.
             */
            mode?: string;
            /**
             * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
             */
            privateKey?: string;
            /**
             * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
             */
            serverCertificate?: string;
            /**
             * A list of alternate names to verify the subject identity in the certificate presented by the client.
             */
            subjectAltNames?: string[];
            /**
             * An optional list of hex-encoded SHA-256 hashes of the authorized client certificates.
             */
            verifyCertificateHash?: string[];
            /**
             * An optional list of base64-encoded SHA-256 hashes of the SPKIs of authorized client certificates.
             */
            verifyCertificateSpki?: string[];
        }

        /**
         * Configuration for the outbound traffic policy.
         */
        export interface SidecarSpecOutboundTrafficPolicy {
            egressProxy?: outputs.networking.v1beta1.SidecarSpecOutboundTrafficPolicyEgressProxy;
            mode?: string;
        }

        export interface SidecarSpecOutboundTrafficPolicyEgressProxy {
            /**
             * The name of a service from the service registry.
             */
            host: string;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: outputs.networking.v1beta1.SidecarSpecOutboundTrafficPolicyEgressProxyPort;
            /**
             * The name of a subset within the service.
             */
            subset?: string;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface SidecarSpecOutboundTrafficPolicyEgressProxyPort {
            number?: number;
        }

        /**
         * Criteria used to select the specific set of pods/VMs on which this `Sidecar` configuration should be applied.
         */
        export interface SidecarSpecWorkloadSelector {
            /**
             * One or more labels that indicate a specific set of pods/VMs on which the configuration should be applied.
             */
            labels?: {[key: string]: string};
        }

        /**
         * Configuration affecting label/content routing, sni routing, etc. See more details at: https://istio.io/docs/reference/config/networking/virtual-service.html
         */
        export interface VirtualServiceSpec {
            /**
             * A list of namespaces to which this virtual service is exported.
             */
            exportTo?: string[];
            /**
             * The names of gateways and sidecars that should apply these routes.
             */
            gateways?: string[];
            /**
             * The destination hosts to which traffic is being sent.
             */
            hosts?: string[];
            /**
             * An ordered list of route rules for HTTP traffic.
             */
            http?: outputs.networking.v1beta1.VirtualServiceSpecHttp[];
            /**
             * An ordered list of route rules for opaque TCP traffic.
             */
            tcp?: outputs.networking.v1beta1.VirtualServiceSpecTcp[];
            /**
             * An ordered list of route rule for non-terminated TLS & HTTPS traffic.
             */
            tls?: outputs.networking.v1beta1.VirtualServiceSpecTls[];
        }

        export interface VirtualServiceSpecHttp {
            /**
             * Cross-Origin Resource Sharing policy (CORS).
             */
            corsPolicy?: outputs.networking.v1beta1.VirtualServiceSpecHttpCorsPolicy;
            /**
             * Delegate is used to specify the particular VirtualService which can be used to define delegate HTTPRoute.
             */
            delegate?: outputs.networking.v1beta1.VirtualServiceSpecHttpDelegate;
            /**
             * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
             */
            directResponse?: outputs.networking.v1beta1.VirtualServiceSpecHttpDirectResponse;
            /**
             * Fault injection policy to apply on HTTP traffic at the client side.
             */
            fault?: outputs.networking.v1beta1.VirtualServiceSpecHttpFault;
            headers?: outputs.networking.v1beta1.VirtualServiceSpecHttpHeaders;
            /**
             * Match conditions to be satisfied for the rule to be activated.
             */
            match?: outputs.networking.v1beta1.VirtualServiceSpecHttpMatch[];
            /**
             * Mirror HTTP traffic to a another destination in addition to forwarding the requests to the intended destination.
             */
            mirror?: outputs.networking.v1beta1.VirtualServiceSpecHttpMirror;
            mirrorPercent?: number;
            /**
             * Percentage of the traffic to be mirrored by the `mirror` field.
             */
            mirrorPercentage?: outputs.networking.v1beta1.VirtualServiceSpecHttpMirrorPercentage;
            mirror_percent?: number;
            /**
             * Specifies the destinations to mirror HTTP traffic in addition to the original destination.
             */
            mirrors?: outputs.networking.v1beta1.VirtualServiceSpecHttpMirrors[];
            /**
             * The name assigned to the route for debugging purposes.
             */
            name?: string;
            /**
             * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
             */
            redirect?: any;
            /**
             * Retry policy for HTTP requests.
             */
            retries?: outputs.networking.v1beta1.VirtualServiceSpecHttpRetries;
            /**
             * Rewrite HTTP URIs and Authority headers.
             */
            rewrite?: outputs.networking.v1beta1.VirtualServiceSpecHttpRewrite;
            /**
             * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
             */
            route?: outputs.networking.v1beta1.VirtualServiceSpecHttpRoute[];
            /**
             * Timeout for HTTP requests, default is disabled.
             */
            timeout?: string;
        }

        /**
         * Cross-Origin Resource Sharing policy (CORS).
         */
        export interface VirtualServiceSpecHttpCorsPolicy {
            /**
             * Indicates whether the caller is allowed to send the actual request (not the preflight) using credentials.
             */
            allowCredentials?: boolean;
            /**
             * List of HTTP headers that can be used when requesting the resource.
             */
            allowHeaders?: string[];
            /**
             * List of HTTP methods allowed to access the resource.
             */
            allowMethods?: string[];
            allowOrigin?: string[];
            /**
             * String patterns that match allowed origins.
             */
            allowOrigins?: any[];
            /**
             * A list of HTTP headers that the browsers are allowed to access.
             */
            exposeHeaders?: string[];
            /**
             * Specifies how long the results of a preflight request can be cached.
             */
            maxAge?: string;
        }

        /**
         * Delegate is used to specify the particular VirtualService which can be used to define delegate HTTPRoute.
         */
        export interface VirtualServiceSpecHttpDelegate {
            /**
             * Name specifies the name of the delegate VirtualService.
             */
            name?: string;
            /**
             * Namespace specifies the namespace where the delegate VirtualService resides.
             */
            namespace?: string;
        }

        /**
         * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
         */
        export interface VirtualServiceSpecHttpDirectResponse {
            /**
             * Specifies the content of the response body.
             */
            body?: any;
            /**
             * Specifies the HTTP response status to be returned.
             */
            status: number;
        }

        /**
         * Fault injection policy to apply on HTTP traffic at the client side.
         */
        export interface VirtualServiceSpecHttpFault {
            /**
             * Abort Http request attempts and return error codes back to downstream service, giving the impression that the upstream service is faulty.
             */
            abort?: any;
            /**
             * Delay requests before forwarding, emulating various failures such as network issues, overloaded upstream service, etc.
             */
            delay?: any;
        }

        export interface VirtualServiceSpecHttpHeaders {
            request?: outputs.networking.v1beta1.VirtualServiceSpecHttpHeadersRequest;
            response?: outputs.networking.v1beta1.VirtualServiceSpecHttpHeadersResponse;
        }

        export interface VirtualServiceSpecHttpHeadersRequest {
            add?: {[key: string]: string};
            remove?: string[];
            set?: {[key: string]: string};
        }

        export interface VirtualServiceSpecHttpHeadersResponse {
            add?: {[key: string]: string};
            remove?: string[];
            set?: {[key: string]: string};
        }

        export interface VirtualServiceSpecHttpMatch {
            /**
             * HTTP Authority values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
             */
            authority?: any;
            /**
             * Names of gateways where the rule should be applied.
             */
            gateways?: string[];
            /**
             * The header keys must be lowercase and use hyphen as the separator, e.g.
             */
            headers?: {[key: string]: any};
            /**
             * Flag to specify whether the URI matching should be case-insensitive.
             */
            ignoreUriCase?: boolean;
            /**
             * HTTP Method values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
             */
            method?: any;
            /**
             * The name assigned to a match.
             */
            name?: string;
            /**
             * Specifies the ports on the host that is being addressed.
             */
            port?: number;
            /**
             * Query parameters for matching.
             */
            queryParams?: {[key: string]: any};
            /**
             * URI Scheme values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
             */
            scheme?: any;
            /**
             * One or more labels that constrain the applicability of a rule to source (client) workloads with the given labels.
             */
            sourceLabels?: {[key: string]: string};
            /**
             * Source namespace constraining the applicability of a rule to workloads in that namespace.
             */
            sourceNamespace?: string;
            /**
             * The human readable prefix to use when emitting statistics for this route.
             */
            statPrefix?: string;
            /**
             * URI to match values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
             */
            uri?: any;
            /**
             * withoutHeader has the same syntax with the header, but has opposite meaning.
             */
            withoutHeaders?: {[key: string]: any};
        }

        /**
         * Mirror HTTP traffic to a another destination in addition to forwarding the requests to the intended destination.
         */
        export interface VirtualServiceSpecHttpMirror {
            /**
             * The name of a service from the service registry.
             */
            host: string;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: outputs.networking.v1beta1.VirtualServiceSpecHttpMirrorPort;
            /**
             * The name of a subset within the service.
             */
            subset?: string;
        }

        /**
         * Percentage of the traffic to be mirrored by the `mirror` field.
         */
        export interface VirtualServiceSpecHttpMirrorPercentage {
            value?: number;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecHttpMirrorPort {
            number?: number;
        }

        export interface VirtualServiceSpecHttpMirrors {
            /**
             * Destination specifies the target of the mirror operation.
             */
            destination: outputs.networking.v1beta1.VirtualServiceSpecHttpMirrorsDestination;
            /**
             * Percentage of the traffic to be mirrored by the `destination` field.
             */
            percentage?: outputs.networking.v1beta1.VirtualServiceSpecHttpMirrorsPercentage;
        }

        /**
         * Destination specifies the target of the mirror operation.
         */
        export interface VirtualServiceSpecHttpMirrorsDestination {
            /**
             * The name of a service from the service registry.
             */
            host: string;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: outputs.networking.v1beta1.VirtualServiceSpecHttpMirrorsDestinationPort;
            /**
             * The name of a subset within the service.
             */
            subset?: string;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecHttpMirrorsDestinationPort {
            number?: number;
        }

        /**
         * Percentage of the traffic to be mirrored by the `destination` field.
         */
        export interface VirtualServiceSpecHttpMirrorsPercentage {
            value?: number;
        }

        /**
         * Retry policy for HTTP requests.
         */
        export interface VirtualServiceSpecHttpRetries {
            /**
             * Number of retries to be allowed for a given request.
             */
            attempts?: number;
            /**
             * Timeout per attempt for a given request, including the initial call and any retries.
             */
            perTryTimeout?: string;
            /**
             * Specifies the conditions under which retry takes place.
             */
            retryOn?: string;
            /**
             * Flag to specify whether the retries should retry to other localities.
             */
            retryRemoteLocalities?: boolean;
        }

        /**
         * Rewrite HTTP URIs and Authority headers.
         */
        export interface VirtualServiceSpecHttpRewrite {
            /**
             * rewrite the Authority/Host header with this value.
             */
            authority?: string;
            /**
             * rewrite the path (or the prefix) portion of the URI with this value.
             */
            uri?: string;
            /**
             * rewrite the path portion of the URI with the specified regex.
             */
            uriRegexRewrite?: outputs.networking.v1beta1.VirtualServiceSpecHttpRewriteUriRegexRewrite;
        }

        /**
         * rewrite the path portion of the URI with the specified regex.
         */
        export interface VirtualServiceSpecHttpRewriteUriRegexRewrite {
            /**
             * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
             */
            match?: string;
            /**
             * The string that should replace into matching portions of original URI.
             */
            rewrite?: string;
        }

        export interface VirtualServiceSpecHttpRoute {
            /**
             * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
             */
            destination: outputs.networking.v1beta1.VirtualServiceSpecHttpRouteDestination;
            headers?: outputs.networking.v1beta1.VirtualServiceSpecHttpRouteHeaders;
            /**
             * Weight specifies the relative proportion of traffic to be forwarded to the destination.
             */
            weight?: number;
        }

        /**
         * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
         */
        export interface VirtualServiceSpecHttpRouteDestination {
            /**
             * The name of a service from the service registry.
             */
            host: string;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: outputs.networking.v1beta1.VirtualServiceSpecHttpRouteDestinationPort;
            /**
             * The name of a subset within the service.
             */
            subset?: string;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecHttpRouteDestinationPort {
            number?: number;
        }

        export interface VirtualServiceSpecHttpRouteHeaders {
            request?: outputs.networking.v1beta1.VirtualServiceSpecHttpRouteHeadersRequest;
            response?: outputs.networking.v1beta1.VirtualServiceSpecHttpRouteHeadersResponse;
        }

        export interface VirtualServiceSpecHttpRouteHeadersRequest {
            add?: {[key: string]: string};
            remove?: string[];
            set?: {[key: string]: string};
        }

        export interface VirtualServiceSpecHttpRouteHeadersResponse {
            add?: {[key: string]: string};
            remove?: string[];
            set?: {[key: string]: string};
        }

        export interface VirtualServiceSpecTcp {
            /**
             * Match conditions to be satisfied for the rule to be activated.
             */
            match?: outputs.networking.v1beta1.VirtualServiceSpecTcpMatch[];
            /**
             * The destination to which the connection should be forwarded to.
             */
            route?: outputs.networking.v1beta1.VirtualServiceSpecTcpRoute[];
        }

        export interface VirtualServiceSpecTcpMatch {
            /**
             * IPv4 or IPv6 ip addresses of destination with optional subnet.
             */
            destinationSubnets?: string[];
            /**
             * Names of gateways where the rule should be applied.
             */
            gateways?: string[];
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: number;
            /**
             * One or more labels that constrain the applicability of a rule to workloads with the given labels.
             */
            sourceLabels?: {[key: string]: string};
            /**
             * Source namespace constraining the applicability of a rule to workloads in that namespace.
             */
            sourceNamespace?: string;
            sourceSubnet?: string;
        }

        export interface VirtualServiceSpecTcpRoute {
            /**
             * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
             */
            destination: outputs.networking.v1beta1.VirtualServiceSpecTcpRouteDestination;
            /**
             * Weight specifies the relative proportion of traffic to be forwarded to the destination.
             */
            weight?: number;
        }

        /**
         * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
         */
        export interface VirtualServiceSpecTcpRouteDestination {
            /**
             * The name of a service from the service registry.
             */
            host: string;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: outputs.networking.v1beta1.VirtualServiceSpecTcpRouteDestinationPort;
            /**
             * The name of a subset within the service.
             */
            subset?: string;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecTcpRouteDestinationPort {
            number?: number;
        }

        export interface VirtualServiceSpecTls {
            /**
             * Match conditions to be satisfied for the rule to be activated.
             */
            match: outputs.networking.v1beta1.VirtualServiceSpecTlsMatch[];
            /**
             * The destination to which the connection should be forwarded to.
             */
            route?: outputs.networking.v1beta1.VirtualServiceSpecTlsRoute[];
        }

        export interface VirtualServiceSpecTlsMatch {
            /**
             * IPv4 or IPv6 ip addresses of destination with optional subnet.
             */
            destinationSubnets?: string[];
            /**
             * Names of gateways where the rule should be applied.
             */
            gateways?: string[];
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: number;
            /**
             * SNI (server name indicator) to match on.
             */
            sniHosts: string[];
            /**
             * One or more labels that constrain the applicability of a rule to workloads with the given labels.
             */
            sourceLabels?: {[key: string]: string};
            /**
             * Source namespace constraining the applicability of a rule to workloads in that namespace.
             */
            sourceNamespace?: string;
        }

        export interface VirtualServiceSpecTlsRoute {
            /**
             * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
             */
            destination: outputs.networking.v1beta1.VirtualServiceSpecTlsRouteDestination;
            /**
             * Weight specifies the relative proportion of traffic to be forwarded to the destination.
             */
            weight?: number;
        }

        /**
         * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
         */
        export interface VirtualServiceSpecTlsRouteDestination {
            /**
             * The name of a service from the service registry.
             */
            host: string;
            /**
             * Specifies the port on the host that is being addressed.
             */
            port?: outputs.networking.v1beta1.VirtualServiceSpecTlsRouteDestinationPort;
            /**
             * The name of a subset within the service.
             */
            subset?: string;
        }

        /**
         * Specifies the port on the host that is being addressed.
         */
        export interface VirtualServiceSpecTlsRouteDestinationPort {
            number?: number;
        }

        /**
         * Configuration affecting VMs onboarded into the mesh. See more details at: https://istio.io/docs/reference/config/networking/workload-entry.html
         */
        export interface WorkloadEntrySpec {
            /**
             * Address associated with the network endpoint without the port.
             */
            address?: string;
            /**
             * One or more labels associated with the endpoint.
             */
            labels?: {[key: string]: string};
            /**
             * The locality associated with the endpoint.
             */
            locality?: string;
            /**
             * Network enables Istio to group endpoints resident in the same L3 domain/network.
             */
            network?: string;
            /**
             * Set of ports associated with the endpoint.
             */
            ports?: {[key: string]: number};
            /**
             * The service account associated with the workload if a sidecar is present in the workload.
             */
            serviceAccount?: string;
            /**
             * The load balancing weight associated with the endpoint.
             */
            weight?: number;
        }

        /**
         * `WorkloadGroup` enables specifying the properties of a single workload for bootstrap and provides a template for `WorkloadEntry`, similar to how `Deployment` specifies properties of workloads via `Pod` templates.
         */
        export interface WorkloadGroupSpec {
            /**
             * Metadata that will be used for all corresponding `WorkloadEntries`.
             */
            metadata?: outputs.networking.v1beta1.WorkloadGroupSpecMetadata;
            /**
             * `ReadinessProbe` describes the configuration the user must provide for healthchecking on their workload.
             */
            probe?: any;
            /**
             * Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
             */
            template: outputs.networking.v1beta1.WorkloadGroupSpecTemplate;
        }

        /**
         * Metadata that will be used for all corresponding `WorkloadEntries`.
         */
        export interface WorkloadGroupSpecMetadata {
            annotations?: {[key: string]: string};
            labels?: {[key: string]: string};
        }

        /**
         * Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
         */
        export interface WorkloadGroupSpecTemplate {
            /**
             * Address associated with the network endpoint without the port.
             */
            address?: string;
            /**
             * One or more labels associated with the endpoint.
             */
            labels?: {[key: string]: string};
            /**
             * The locality associated with the endpoint.
             */
            locality?: string;
            /**
             * Network enables Istio to group endpoints resident in the same L3 domain/network.
             */
            network?: string;
            /**
             * Set of ports associated with the endpoint.
             */
            ports?: {[key: string]: number};
            /**
             * The service account associated with the workload if a sidecar is present in the workload.
             */
            serviceAccount?: string;
            /**
             * The load balancing weight associated with the endpoint.
             */
            weight?: number;
        }

    }
}

export namespace security {
    export namespace v1 {
        /**
         * Request authentication configuration for workloads. See more details at: https://istio.io/docs/reference/config/security/request_authentication.html
         */
        export interface RequestAuthenticationSpec {
            /**
             * Define the list of JWTs that can be validated at the selected workloads' proxy.
             */
            jwtRules?: outputs.security.v1.RequestAuthenticationSpecJwtRules[];
            /**
             * Optional.
             */
            selector?: outputs.security.v1.RequestAuthenticationSpecSelector;
            targetRef?: outputs.security.v1.RequestAuthenticationSpecTargetRef;
        }

        export interface RequestAuthenticationSpecJwtRules {
            /**
             * The list of JWT [audiences](https://tools.ietf.org/html/rfc7519#section-4.1.3) that are allowed to access.
             */
            audiences?: string[];
            /**
             * If set to true, the original token will be kept for the upstream request.
             */
            forwardOriginalToken?: boolean;
            /**
             * List of header locations from which JWT is expected.
             */
            fromHeaders?: outputs.security.v1.RequestAuthenticationSpecJwtRulesFromHeaders[];
            /**
             * List of query parameters from which JWT is expected.
             */
            fromParams?: string[];
            /**
             * Identifies the issuer that issued the JWT.
             */
            issuer: string;
            /**
             * JSON Web Key Set of public keys to validate signature of the JWT.
             */
            jwks?: string;
            /**
             * URL of the provider's public key set to validate signature of the JWT.
             */
            jwksUri?: string;
            /**
             * URL of the provider's public key set to validate signature of the JWT.
             */
            jwks_uri?: string;
            /**
             * This field specifies a list of operations to copy the claim to HTTP headers on a successfully verified token.
             */
            outputClaimToHeaders?: outputs.security.v1.RequestAuthenticationSpecJwtRulesOutputClaimToHeaders[];
            /**
             * This field specifies the header name to output a successfully verified JWT payload to the backend.
             */
            outputPayloadToHeader?: string;
        }

        export interface RequestAuthenticationSpecJwtRulesFromHeaders {
            /**
             * The HTTP header name.
             */
            name: string;
            /**
             * The prefix that should be stripped before decoding the token.
             */
            prefix?: string;
        }

        export interface RequestAuthenticationSpecJwtRulesOutputClaimToHeaders {
            /**
             * The name of the claim to be copied from.
             */
            claim?: string;
            /**
             * The name of the header to be created.
             */
            header?: string;
        }

        /**
         * Optional.
         */
        export interface RequestAuthenticationSpecSelector {
            /**
             * One or more labels that indicate a specific set of pods/VMs on which a policy should be applied.
             */
            matchLabels?: {[key: string]: string};
        }

        export interface RequestAuthenticationSpecTargetRef {
            group?: string;
            kind?: string;
            name?: string;
            namespace?: string;
        }

    }

    export namespace v1beta1 {
        /**
         * Peer authentication configuration for workloads. See more details at: https://istio.io/docs/reference/config/security/peer_authentication.html
         */
        export interface PeerAuthenticationSpec {
            /**
             * Mutual TLS settings for workload.
             */
            mtls?: outputs.security.v1beta1.PeerAuthenticationSpecMtls;
            /**
             * Port specific mutual TLS settings.
             */
            portLevelMtls?: {[key: string]: outputs.security.v1beta1.PeerAuthenticationSpecPortLevelMtls};
            /**
             * The selector determines the workloads to apply the ChannelAuthentication on.
             */
            selector?: outputs.security.v1beta1.PeerAuthenticationSpecSelector;
        }

        /**
         * Mutual TLS settings for workload.
         */
        export interface PeerAuthenticationSpecMtls {
            /**
             * Defines the mTLS mode used for peer authentication.
             */
            mode?: string;
        }

        export interface PeerAuthenticationSpecPortLevelMtls {
            /**
             * Defines the mTLS mode used for peer authentication.
             */
            mode?: string;
        }

        /**
         * The selector determines the workloads to apply the ChannelAuthentication on.
         */
        export interface PeerAuthenticationSpecSelector {
            /**
             * One or more labels that indicate a specific set of pods/VMs on which a policy should be applied.
             */
            matchLabels?: {[key: string]: string};
        }

        /**
         * Request authentication configuration for workloads. See more details at: https://istio.io/docs/reference/config/security/request_authentication.html
         */
        export interface RequestAuthenticationSpec {
            /**
             * Define the list of JWTs that can be validated at the selected workloads' proxy.
             */
            jwtRules?: outputs.security.v1beta1.RequestAuthenticationSpecJwtRules[];
            /**
             * Optional.
             */
            selector?: outputs.security.v1beta1.RequestAuthenticationSpecSelector;
            targetRef?: outputs.security.v1beta1.RequestAuthenticationSpecTargetRef;
        }

        export interface RequestAuthenticationSpecJwtRules {
            /**
             * The list of JWT [audiences](https://tools.ietf.org/html/rfc7519#section-4.1.3) that are allowed to access.
             */
            audiences?: string[];
            /**
             * If set to true, the original token will be kept for the upstream request.
             */
            forwardOriginalToken?: boolean;
            /**
             * List of header locations from which JWT is expected.
             */
            fromHeaders?: outputs.security.v1beta1.RequestAuthenticationSpecJwtRulesFromHeaders[];
            /**
             * List of query parameters from which JWT is expected.
             */
            fromParams?: string[];
            /**
             * Identifies the issuer that issued the JWT.
             */
            issuer: string;
            /**
             * JSON Web Key Set of public keys to validate signature of the JWT.
             */
            jwks?: string;
            /**
             * URL of the provider's public key set to validate signature of the JWT.
             */
            jwksUri?: string;
            /**
             * URL of the provider's public key set to validate signature of the JWT.
             */
            jwks_uri?: string;
            /**
             * This field specifies a list of operations to copy the claim to HTTP headers on a successfully verified token.
             */
            outputClaimToHeaders?: outputs.security.v1beta1.RequestAuthenticationSpecJwtRulesOutputClaimToHeaders[];
            /**
             * This field specifies the header name to output a successfully verified JWT payload to the backend.
             */
            outputPayloadToHeader?: string;
        }

        export interface RequestAuthenticationSpecJwtRulesFromHeaders {
            /**
             * The HTTP header name.
             */
            name: string;
            /**
             * The prefix that should be stripped before decoding the token.
             */
            prefix?: string;
        }

        export interface RequestAuthenticationSpecJwtRulesOutputClaimToHeaders {
            /**
             * The name of the claim to be copied from.
             */
            claim?: string;
            /**
             * The name of the header to be created.
             */
            header?: string;
        }

        /**
         * Optional.
         */
        export interface RequestAuthenticationSpecSelector {
            /**
             * One or more labels that indicate a specific set of pods/VMs on which a policy should be applied.
             */
            matchLabels?: {[key: string]: string};
        }

        export interface RequestAuthenticationSpecTargetRef {
            group?: string;
            kind?: string;
            name?: string;
            namespace?: string;
        }

    }
}

export namespace telemetry {
    export namespace v1alpha1 {
        /**
         * Telemetry configuration for workloads. See more details at: https://istio.io/docs/reference/config/telemetry.html
         */
        export interface TelemetrySpec {
            /**
             * Optional.
             */
            accessLogging?: outputs.telemetry.v1alpha1.TelemetrySpecAccessLogging[];
            /**
             * Optional.
             */
            metrics?: outputs.telemetry.v1alpha1.TelemetrySpecMetrics[];
            /**
             * Optional.
             */
            selector?: outputs.telemetry.v1alpha1.TelemetrySpecSelector;
            targetRef?: outputs.telemetry.v1alpha1.TelemetrySpecTargetRef;
            /**
             * Optional.
             */
            tracing?: outputs.telemetry.v1alpha1.TelemetrySpecTracing[];
        }

        export interface TelemetrySpecAccessLogging {
            /**
             * Controls logging.
             */
            disabled?: boolean;
            /**
             * Optional.
             */
            filter?: outputs.telemetry.v1alpha1.TelemetrySpecAccessLoggingFilter;
            /**
             * Allows tailoring of logging behavior to specific conditions.
             */
            match?: outputs.telemetry.v1alpha1.TelemetrySpecAccessLoggingMatch;
            /**
             * Optional.
             */
            providers?: outputs.telemetry.v1alpha1.TelemetrySpecAccessLoggingProviders[];
        }

        /**
         * Optional.
         */
        export interface TelemetrySpecAccessLoggingFilter {
            /**
             * CEL expression for selecting when requests/connections should be logged.
             */
            expression?: string;
        }

        /**
         * Allows tailoring of logging behavior to specific conditions.
         */
        export interface TelemetrySpecAccessLoggingMatch {
            /**
             * This determines whether or not to apply the access logging configuration based on the direction of traffic relative to the proxied workload.
             */
            mode?: string;
        }

        export interface TelemetrySpecAccessLoggingProviders {
            /**
             * Required.
             */
            name: string;
        }

        export interface TelemetrySpecMetrics {
            /**
             * Optional.
             */
            overrides?: outputs.telemetry.v1alpha1.TelemetrySpecMetricsOverrides[];
            /**
             * Optional.
             */
            providers?: outputs.telemetry.v1alpha1.TelemetrySpecMetricsProviders[];
            /**
             * Optional.
             */
            reportingInterval?: string;
        }

        export interface TelemetrySpecMetricsOverrides {
            /**
             * Optional.
             */
            disabled?: boolean;
            /**
             * Match allows provides the scope of the override.
             */
            match?: any;
            /**
             * Optional.
             */
            tagOverrides?: {[key: string]: outputs.telemetry.v1alpha1.TelemetrySpecMetricsOverridesTagOverrides};
        }

        export interface TelemetrySpecMetricsOverridesTagOverrides {
            /**
             * Operation controls whether or not to update/add a tag, or to remove it.
             */
            operation?: string;
            /**
             * Value is only considered if the operation is `UPSERT`.
             */
            value?: string;
        }

        export interface TelemetrySpecMetricsProviders {
            /**
             * Required.
             */
            name: string;
        }

        /**
         * Optional.
         */
        export interface TelemetrySpecSelector {
            /**
             * One or more labels that indicate a specific set of pods/VMs on which a policy should be applied.
             */
            matchLabels?: {[key: string]: string};
        }

        export interface TelemetrySpecTargetRef {
            group?: string;
            kind?: string;
            name?: string;
            namespace?: string;
        }

        export interface TelemetrySpecTracing {
            /**
             * Optional.
             */
            customTags?: {[key: string]: any};
            /**
             * Controls span reporting.
             */
            disableSpanReporting?: boolean;
            /**
             * Allows tailoring of behavior to specific conditions.
             */
            match?: outputs.telemetry.v1alpha1.TelemetrySpecTracingMatch;
            /**
             * Optional.
             */
            providers?: outputs.telemetry.v1alpha1.TelemetrySpecTracingProviders[];
            /**
             * Controls the rate at which traffic will be selected for tracing if no prior sampling decision has been made.
             */
            randomSamplingPercentage?: number;
            useRequestIdForTraceSampling?: boolean;
        }

        /**
         * Allows tailoring of behavior to specific conditions.
         */
        export interface TelemetrySpecTracingMatch {
            /**
             * This determines whether or not to apply the tracing configuration based on the direction of traffic relative to the proxied workload.
             */
            mode?: string;
        }

        export interface TelemetrySpecTracingProviders {
            /**
             * Required.
             */
            name: string;
        }

    }
}
